# 1장
1.1 프로그래밍 언어로서의 자바스크립트
======

자바스크립트의 특징
------
자바스크립트의 다양한 특징 중에서도 특히 함수가 일급 객체라는 점, 클로저를 이용할 수 있다는 점, 동적 프로토타입 기반의 객체 지향 언어라는 점이 자바스크립트를 다른 언어보다 더 강력한 프로그래밍 언어로 만들었다.

1.2 자바스크립트의 역사
======
자바스크립트는 1996년에는 마이크로소프트 사의 Internet Explore 3.0에 탑재되었으며 Java 애플릿으로 구현된 웹 브라우저의 지지부진한 보급과 맞물려 빠르게 보급되었다.<br/>
자바스크립트가 간단한 스크립트 언어가 아니라 고성능의 웹 애플리케이션을 만들 수 있는 본격적인 객체 지향 언어이다.


# 2장
실습 준비하기
======
자바스크립트로 프로그래밍 기초를 배우기 전에 자바스크립트 프로그램을 실행하는 환경을 준비한다. Node.js를 설치하고 텍스트 편집기(비주얼 스튜디오 코드)를 준비한다.<br/>
앞으로 자바스크립트 파일과 HTML 파일을 만들고 저장할 것이다. 저장할 때는 파일 이름 끝에 확장자를 붙여서 저장해야 한다.

간간한 예제
======
``` javascript
function fact(n){
  if(n<=1) return n;
  return n*fact(n-1);
}
for(var i=1; i<10; i++){
    console.log(i + "! = " + fact(i));
  }
```

프로그램 실행법
======
앞 절에서 만든 프로그램을 다음과 같은 방법으로 실행할 수 있다.<br/>

웹 브라우저의 콘솔에서 실행하기
------
<p align="center"><img src="/Week1/img/Modern_Javascript_2_3_1.png" width="500" height="400"></p><br/>

자바스크립트 코드를 HTML 문서에 삽입하여 웹 브라우저로 실행하기
------
텍스트 편집기로 factorial.html을 작성한다.

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>팩토리얼 계산</title>
</head>
<body>
  <script>
  function fact(n){
  if(n<=1) return n;
  return n*fact(n-1);
}
for(var i=1; i<10; i++){
    console.log(i + "! = " + fact(i));
  }
  </script>
</body>
</html>
```
크롬으로 factorial.html을 열고 콘솔을 켜면 콘솔에 실행 결과가 표시된다.<br/>
<p align="center"><img src="Week1/img/Modern_Javascript_2_3_2.png" width="500" height="400"></p><br/>

factorial.html의 console.log(...) 부분을 document.write(...)로 바꾸면 출력 결과를 웹 페이지의 창 안에서 확인할 수 있습니다.(factorial-write.html)<br/>
`document.write(i + "! = " + fact(i) + "<br />");`<br/>
수정된 HTML 파일을 웹 브라우저로 열면 다음과 같이 표시된다.<br/>
<p align="center"><img src="/Week1/img/Modern_Javascript_2_3_3.png" width="500" height="400"></p><br/>
document.write를 사용하면 콘솔 화면을 켤 필요가 없다. 그러나 실무에서는 웹 페이지에 document.write를 사용하여 출력하는 경우가 매우 드물다.<br/>

Node.js의 대화형 모드로 실행하기
------
자바스크립트 코드를 script 요소 안에 작성하면 자바스크립트 프로그램이 길어졌을 때 전체 HTML을 읽기가 힘들어진다. 이떄 다른 파일에 저장한 자바스크립트 코드를 읽어 들이도록 구현하면 전체 HTML을 편하게 읽을 수 있다.<br/>
다른 자바스크립트 파일을 읽어 들이도록 설정하려면 script 요소의 scr 속성에 읽어 들이려는 파일의 경로를 입력한다.<br/>
`<script src="다른 파일의 경로"</script>`<br/>
다음 factorial2.html은 factorial.js를 읽어 들이도록 수정한 것이다.

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8">
    <title>팩토리얼 계산</title>
  </head>
  <body>
    <script src="./factorial.js"></script>
  </body>
</html>
```
Node.js로 파일을 읽어 들여 실행하기
------
Node.js는 주로 서버 측 자바스크립트 실행 환경으로 사용된다. Node.js 위에서 동작하는 서버 애플리케이션을 작성하면 다양한 웹 서버를 구축할 수 있고 일반 PC에서도 설치할 수 있어서 자바스크립트 프로그램을 여기서 실행시킬 수도 있다.<br/>
Node.js를 실행시키려면 명령프롬프트를 사용한다.<br/>
<p align="center"><img src="/Week1/img/Modern_Javascript_2_3_4.png" width="500" height="400"></p><br/>
Node.js로 파일을 읽어 들여 실행하면 규모가 큰 프로그램도 텍스트 편집기로 작성하거나 편집한 후에 실행시킬 수 있어 매우 편리하다. Node.js로 파일을 읽어 들여 실행하는 방법은 다음과 같다.<br/>
<p align="center"><img src="/Week1/img/Modern_Javascript_2_3_5.png" width="500" height="400"></p><br/>

프로그램 작성법
======
이 절에서는 자바스크립트 프로그램의 기본 작성법을 배운다.<br/>

문자코드
------
자바스크립트 프로그램은 유니코드 문자로 작성한다.<br/>

대문자와 소문자
-------
자바스크립트 프로그램은 알파벳 대문자와 소문자를 구별한다.<br/>

토큰과 공백 문자
-------
**토큰**<br/>
프로그램을 구성하는 최소 단위를 **토큰(어휘)**이라고 한다. 자바스크립트 인터프리터는 프로그램을 실행하기 앞서 프로그램을 토큰으로 분해하는데 이 동작을 어휘 분석이라고 한다. 그 후에 토큰을 한 줄로 나열하고 이것이 자바스크립트의 구문 규약에 비추어 보았을 때 올바른 프로그램인지 판정한다. 이 동작을 구문 분석(파싱)이라고 한다. 즉, 토큰은 의미를 가지는 최소한의 문자 덩어리라고 할 수 있다.<br/>
예를 들어 return n*fact(n-1); 부분을 토큰으로 나누어 보자.<br/>
`return | n | * | fact | ( | n | - | 1 | ) | ; `

**공백 문자**<br/>
인접한 토큰을 공백 등을 넣지 않고 나열하기만 해서는 토큰을 판별할 수 없다. 그래서 프로그래밍 언어에서는 토큰과 토큰 사이에 공백 문자를 입력해서 구분한다. 이때 토큰과 토큰 사이에 공백 문자를 여러 개 입력해도 공백 문자를 하나만 입력한 것으로 간주한다.<br/>

**공백 문자 생략하기**<br/>
토큰과 토큰 사이에 공백 문자가 없어도 토큰을 판별할 수 있는 경우가 있다. =, +, *, /와 같은 산술 연산자 앞뒤의 공백문자, 괄호 앞뒤의 공백문자, 세미클론(;), 쉼표(,), 클론(:), 마침표(.) 앞뒤의 공백 문자는 생략할 수 있다. 이러한 토큰과 토큰을 분리하기 때문에 분리자 또는 구분자라고 부른다.

**프로그램 가독성 높이기**<br/>
토큰 사이에는 공백 문자를 여러 개 입력해도 하나로 간주하는 성질을 응용하면 프로그램을 사람들이 이해하기 쉽게 작성할 수 있다. 이를 일컬어 프로그램의 가독성 높이기(prettify 또는 beautify)라고 한다.<br/>
`function fact(n) {if(n<=1)return n;return n*fact(n-1);}`을 사람들이 편하게 읽을 수 있도록 공백 문자, 탭 문자, 개행 문자를 적절히 추가해서 다음과 같이 작성하는 편이 좋다.<br/>
```
function fact(n){
    if( n <=1 ) return n;
    return n*fact(n-1);
}
```

문장
------
**문장**<br/>
자바스크립트는 토큰을 나열하여 한 문장을 만들고, 문장을 이용해 컴퓨터에 명령을 내리고, 문장은 세미클론(;)으로 끝난다.<br/>
```javascript
console.log(i + "! = " + fact(i));
```
이 코드는 **소괄호 안에 들어 있는 값을 콘솔에 출력하라**는 명령을 표현한다.<br/>

**복합문**<br/>
문장 여러 개를 중괄호({})로 감싼 코드를 복합문 또는 블록문이라고 한다.<br/>
```javascript
{
    sum = sum + x;
    console.log("sum = " + x);
}
```

**빈 문장**<br/>
빈 문장이란 문장이 하나도 없는 문장을 뜻한다. 빈 문장은 세미클론으로 작성한다.<br/>
```javascript
;
```

**세미클론 자동 추가**<br/>
문장을 작성하고 다음 줄에 문장을 작성하면 앞 문장 끝에 세미클론이 없어도 자바스크립트 엔진이 자동으로 세미클론을 추가한다.
```javascript
console.log("Hello")
console.log("Hi")
```
자바스크립트 엔진은 위의 코드를 다음과 같이 해석한다.
```javascript
console.log("Hello");
console.loh("Hi");
```
하지만 자바스크립트 엔진은 세미클론을 생략한 줄이 다음 줄과 이어지고 있다고 판단하면 세미클론을 자동으로 추가하지 않는다.
```javascript
c = a + b
(x+y).toString()
```
이 코드에서 2번째 줄의 (x+y)가 첫 번째 줄의 b 함수를 호출하는 코드라고 볼 수 있으므로 자바스크크립트 엔진은 다음과 같이 해석한다.
```javascript
c = a + b(x+y).toString();
```
이렇게 세미클론이 자동으로 추가되는 것을 기대하는 행위는 예상하지 못한 오류의 원인이 될 수 있다. 그러므로 문장 끝에는 반드시 세미클론을 입력한다.

주석
------
주석은 프로그램의 소스 코드에 삽입하는 설명문이다. 자바스크립트에서는 주석을 다음 두 가지 방법으로 작성할 수 있다.<br/>
`/* 주석문 */`<br/>
`// 주석문`<br/>


# 3장
변수
======
변수는 프로그램을 작성하는 데 가장 중요한 요소이다.

변수
------
변수는 값을 담기 위해 이름을 붙인 상자이다. 변수는 컴퓨터의 메모리에 일정한 크기의 영역으로 생선된다.

변수 선언
------
프로그램에서 변수를 사용하려면 우선 다음과 같이 변수를 선언한다.
```javascript
var sum;
```
이 문장이 실행되면 메모리에는 sum이라는 이름이 붙은 역역이 생성된다. 위 코드의 var은 자바스크립트 키워드로 변수를 선언하기 위한 **선언자**이다. sum부분은 **변수 이름**이라고 부르며, 이 변수 이름을 이용해 변수 값을 읽거나 쓸 수 있다. 자바스크립트에는 변수 타입이 없으므로 변수 선언자는 var 하나뿐이다. *(ECMAScript 6부터는 var 외에도 let과 const라는 선언자가 추가되었다. var과 마찬가지로 이 선언자로 선언한 변수는 타입이 없다.)* 따라서 모든 데이터 타입의 값을 저정할 수 있다.<br/>
쉼표(,)를 사용하면 변수 여러 개를 한 개의 문장으로 선언할 수 있다.
```javascript
var sum, a;
```
변수를 선언하기만 하면 변수 안에는 정의되지 않았음을 뜻하는 undefined라는 값이 들어간다.
```javascript
var x;
console.log(x); //undefined
```
대입 연산자(=)를 사용하면 변수에 값을 대입할 수 있다.
```javascript
x = 2;
```
변수를 선언하면서 초깃값을 설정할 수도 있고 변수를 여러 개 선언하고 초깃값 설정을 쉼표로 구분하여 한 문장만 사용하여 표현할 수도 있다.
```javascript
var x = 5;
var a = 1, b = 2, c = 3;
```

변수 선언 생략
------
var 문으로 선언하지 않은 변수 값을 읽으려고 시도하면 참조 오류가 발생한다.
```javascript
console.log(x); // ReferenceError: x is not defined
```
그러나 var문으로 선언하지 않은 변수에 값을 대입할 때는 오류가 발생하지 않는다.
```javascript
x = 2;
console.log(x); // 2
```
변수를 선언하지 않은 상태에서 값을 대입하면 자바스크립트 엔진이 그 변수를 자동으로 전역 변수로 선언하기 때문이다. 그러나 변수를 선언하지 않고 변수를 사용하는 행위는 버그의 원인이 될 수 있다.

변수 끌어올림과 변수 중복 선언
------
프로그램은 작성한 순서에 따라 윗줄부터 차례대로 실행된다. 하지만 변수 선언은 이 원칙을 따르지 않는다.
```javascript
console.log(x);
var x;
```
이 코드에서 1번째 줄은 아직 변수 x가 선언되지 않았기 때문에 오류거 발생할 것 같지만 실제로는 오류가 발생하지 않고 undefined가 출력된다. 이는 프로그램 중간에서 변수를 선언하더라도 변수가 프로그램 첫머리에 선언된 것처엄 다은 문장 앞에 생성되기 때문이다. 이를 **변수 선언의 끌어올림**(호이스팅, hoisting)이라고 한다. 단, 선언과 동시에 대입하는 코드는 끌어올림을 하지않는다.
```javascript
console.log(x); // undefined
var x = 5;
console.log(x); // 5
```

변수의 명명 규칙
------
변수, 함수, 라벨 이름 등 사용자가 정의하는 이름을 식별자라고 한다. 식별자는 다음과 같은 명명 규칙을 따라야만 한다.<br/>
　• 사용할 수 있는 문자는 알파벳(a~z, A~Z), 숫자(0~9), 밑줄(_), 달러 기호($)다.<br/>
　• 첫 글자로는 숫자를 사용할 수 없다.<br/>
　• 예약어를 식별자로 사용할 수 없다.<br/>

데이터타입
======
데이터 타입은 프로그래밍 언어릐 기본적인 구성 요소이다.

데이터 타입과 변수의 동적 타이핑
------
데이터 타입이란 숫자나 문자열처럼 변수에 저장하는 데이터 종류를 뜻한다. C나 Java 등의 프로그래밍 언어에는 정수 타입 변수, 부동소수점 타입 변수 등이 있어서 그 변수의 타입과 일치하는 데이터만 저장할 수 있다. 이처럼 변수에 타입이 있는 언어를 **정적 타입 언어**(static typed language)라고 부른다. 하지만 자바스크립트에는 변수에 타입이 없으므로 변수에 모든 타입의 데이터를 저장할 수 있다.
```javascript
var pi = 3.14;
console.log(pi); // 3.14
pi = '원주율';
console.log(pi); // 원주율
```
자바스크립트에서는 같은 변수에 숫자나 문자열과 같은 다양할 타입의 데이터를 대입할 수 있다. 이처럼 실행할 때 변수에 저장된 데이터 타입을 동적으로 바꿀 수 있는 언어를 **동적 타입 언어**(Dynamic typed language)라고 부른다.

데이터 타입의 분류
------
자바스크립트가 처리할 수 있는 데이터 타입은 크게 **원시 타입**(primitive type)과 **객체 타입**으로 나눌 수 있다.<br/>
원시 타입에 속하는 값에는 숫자, 문자열, 논리값이 있다. 특수한 값(undefine, null)과 심벌(symbol)도 원시 타입에 속한다.원시 타입 데이터는 데이터를 구성하는 가장 기본적인 요소로 불변 값으로 정의되어 있다.<br/>
원시 타입에 속하지 않는 자바스크립트의 값은 **객체**라고 한다. 객체는 변수 여러 개가 모여서 만들어진 복합 데이터 타입이다.

숫자
------
대다수의 프로그래밍 언어에는 정수 타입과 부동소수점 타입이 따로 있지만 자바스크립트에는 타입이 없으므로 숫자를 모두 64비트 부동소수점으로 표현한다. 이는 C나 Java에서 사용하는 double 타입에 해당한다.

문자열
------
자바스크립트의 문자열은 길이가 16비트인 유니코드 문자(UTF-16 코드)를 나열한 것으로 전 세계에서 사용하는 문자를 대부분 표현할 수 있다. 문자열 리터럴은 작은따옴표(')나 큰따옴표(")를 문자열의 앞뒤에 붙여서 표현한다.

논리값
------
논리값은 조건식이 참인지 거짓인지 표현하기 위해 사용하는 값이다. 논리값에는 true와 false, 두 가지 종류가 있다.

특수한 값
------
**값이 없음**을 표현하기 위해 특수한 값에는 null과 undefined가 있다. undefined는 정의되지 않은 상태를 뜻한다. 변수 값이 undefined가 되는 것은 값을 할당하지 않은 결과이다.<br/>
null은 **아무것도 없음**을 값으로 표현한 리터럴 이다.

ECMAScript 6부터 추가된 데이터 타입
======
이 절에서는 ECMAScript 6부터 추가된 데이터 타입인 심벌(Symbol)과 템플릿 리터럴(Template literals)을 소개한다.

심벌
------
심벌은 ECMAScript 6부터 새롭게 추가된 원시 값이다. 심벌은 자기 자신을 제외한 그 어떤 값과도 다른 유일무이한 값이다.<br/>
**심벌의 생성**<br/>
심벌은 Symbol()을 사용하여 생성한다.
```javascript
var sym1 = Symbol();
```
Symbol()은 호출할 때마다 새로운 값을 만든다. 이를 확인하기 위해 또 다른 심벌을 생성해 보자.
```javascript
var sym2 = Symbol();
```
다음처럼 sym1 값과 sym2 값이 다르다는 사실을 확인할 수 있다.
```javascript
console.log(sym1 == sym2); // false
```
또한 Symbol()에 인수를 전달하면 생성된 심벌의 설명을 덧붙일 수 있고 심벌의 설명은 toString() 메서드를 사용해서 확인할 수 있다.
```javascript
var HEART = Symbol("하트");
console.log(HEART.toString()); // Symbol(하트)
```
예를 들어 오셀로 게임을 만들 때 칸의 상태를 값으로 표현하는 코드를 작성해보자.
```javascript
var NONE = 0; // 칸에 돌이 놓여 있지 않은 상태
var BLACK = -1; // 칸에 검은 돌이 놓여 있는 상태
var WHITE = 1; // 칸에 흰 돌이 놓여 있는 상태
```
심벌을 활용하면 앞의 코드를 다음처럼 고칠 수 있다.
```javascript
var NONE = Symbol("none");
var BLACK = Symbol("black");
var WHITE = Symbol("white");
```

심벌과 문자열 연결하기
------
Symbol.for()를 활용하면 문자열과 연결된 심벌을 생성할 수 있다.
```javascript
var sym1 = Symbol.for("club");
```
그러면 전역 레지스트리에 심벌이 만들어진다. 또한 전역 레지스트리에서 그 심벌을 위에 지정한 문자열로 불러올 수 있다.
```javascript
var sym2 = Symbol.for("club");
console.log(sym1 == sym2); // true
```
이 기능을 활용하면 코드의 어느 부분에서도 같은 심벌을 공유할 수 있다.
```javascript
var sym1 = Symbol.for("club");
var sym2 = Symbol("club");
console.log(Symbol.keyFor(sym1)); // club
console.log(Symbol.keyFor(sym2)); // undefined
```

템플릿 리터럴
------
템플릿 리터럴은 ECMAScript 6부터 추가된 문자열 표현 구문이다. 템플릿이란 일부만 변경해서 반복하거나 재사용할 수 있는 틀을 말한다. 템플릿 리터럴을 사용하면 표현식의 값을 문자열에 추가하거나 여러 줄의 문자열을 표현할 수 있다.<br/>

**기본적인 사용법**<br/>
템플릿 리터럴은 역따옴표(`)로 묶은 문자열이다. 문자열 리터럴에서 줄 바꿈 문자를 표현할 때는 이스케이프 시퀀스(\n)을 사용했지만, 테플릿 리터럴을 사용하면 일반적인 줄 바꿈 문자를 사용할 수 있다.
```javascript
var t = 'Man errs as long as
he strives.';
```
이 문자열을 문자열 리터럴로 표현하면 다음과 같다.
```javascript
var t = "Man errs as long as\nhe strives.";
```
물론 템플릿 리터럴에서도 이스케이프 시퀀스를 사용할 수 있다.
```javascript
var t = 'Man errs as long as\nhe strives.';
```
이스케이프 시퀀스 문자를 그대로 출력하려면 템플릿 리터럴 앞에 String.raw를 붙인다.
```javascript
var t = String.raw'Man errs as long as\nhe strives.';
```
이 문자열을 문자열 리터럴로 표현하면 다음과 같은 모습이 된다.
```javascript
var t = "Man errs as long as\\nhe strives.";
```
템플릿 리터럴 앞에 붙은 String.raw는 **태그 함수**라고 부른다.

**보간 표현식**<br/>
템플릿 리터럴 안에는 **플레이스 홀더**를 넣을 수 있다. 플레이스 홀더는 ${...}로 표기한다. 자바스크립트 엔진은 플레이스 홀더 안에 든 ... 부분을 표현식으로 간주하여 평가(evaluation)한다. 이를 활용하여 문자열 안에 변수나 표현식의 결괏값을 삽입할 수 있다.
```javascript
var a = 2, b = 3;
console.log('${a} + ${b} = ${a+b}'); // 2 + 3 = 5
var now = new Date();
console.log('오늘은 ${now.getMonth()+1} 월 ${now.getDate()} 일입니다.'); //오늘은 8 월 1 일 입니다
```


# 4장
객체의 기초 ① 객체 리터럴
======
자바스크립트에서는 원시 타입을 제외한 모든 값이 객체이다. 객체는 자바스크립트에서 가장 중요한 데이터 타입이다. 객체는 객체 리터럴과 생성자로 생성할 수 있다.

객체
------
객체는 이름과 값을 한 쌍으로 묶은 데이터를 여러 개 모은 것이다. 즉, 객체는 데이터 여러 개를 하나로 모은 복합 데이터로 **연관 배열** 또는 **사전**이라고도 부른다.<br/>
객체에 포함된 데이터 하나(이름과 값의 쌍)를 가리켜 객체의 **프로퍼티**라고 부르고 프로퍼티의 이름 부분을 **프로퍼티 이름** 또는 **키**라고 부른다.

객체 리터럴로 객체 생성하기
------
다음 코드는 트럼프 카드의 정보를 객체 리터럴로 표현한 것이다.
```javascript
var card = { suit: "하트", rank: "A" };
```
{...} 부분이 바로 객체 리터럴이며, 객체 리터럴을 변수 card에 대입하고 있다. 프로퍼티 이름과 프로퍼티 값은 **suit: "하트"**처럼 클론(:)을 사용하여 구분하며 중괄호({})안에 있는 프로터티들은 쉼표(,)로 구분한다. 프로퍼티 이름으로는 모든 식별자와 문자열 리터럴(빈 문자열고 사용 가능)을 사용할 수 있다. 즉 앞 코드에 있는 프로퍼티 이름은 문자열로 바꾸어 작성할 수 있다.
```javascript
var card = { "suit": "하트", 'rank': "A" };
```
프로퍼티 값에는 모든 데이터 타입의 값과 표현식을 대입할 수 있다.<br/>
변수에 대입된 객체 안의 프로퍼티 값을 읽거나 쓸 때는 **마침표(.) 연산자** 또는 **대괄호([]) 연산자**를 사용한다.
```javascript
card.suit // 하트
card["rank"] // A
```
마침표로 프로퍼티를 읽거나 쓸 때는 프로퍼티 이름 즉, 식별자만 사용할 수 있다. 대괄호로 프로퍼티를 읽거나 쓸 때는 프로퍼티 이름 또는 문자열을 반환하는 표현식을 사용할 수 있다.<br/>
객체에 없는 프로퍼티를 읽으려고 시도하면 undefined를 반환한다.
```javascript
card.color // undefined
```
객체 리터럴 안에 어떠한 프로퍼티도 작성하지 않으면 빈 객체가 생성된다.
```javascript
var obj = {};
console.log(obj); // Object{}
```

프로퍼티 추가와 삭제
------
없는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가된다.
```javascript
card.value = 14;
console.log(card); // Object {suit: "하트", rank: "A", value: 14}
```
delete 연산자를 사용하면 프로퍼티를 삭제할 수 있다.
```javascript
delete card.rank;
console.log(card); // Object {suit: "하트", value: 14}
```

in 연산자로 프로퍼티가 있는지 확인하기
------
in 연산자를 사용하면 객체에 특정 프로퍼티가 있는지 확인할 수 있다. 프로퍼티가 객체에 포함되었을 때는 true를 반환하고 포함되지 않았을 때는 false를 반환한다.<br/>
```javascript
var card = { suit: "하트", rank: "A"};
console.log("suit" in card);  // true
console.log("color" in card); // false
```
원래 toString 프로퍼티는 card 객체 안에 없지만 다음 코드를 보면 toString 프로퍼티가 card에 있다는 결과가 나온다.
```javascript
console.log("toString" in card); // true
```
이는 card가 Object 객체를 상속받았기 때문이다.

객체 리터럴 예제
------
**좌표평면의 점을 표현하는 객체**
```javascript
var p = { x: 1.0, y: 2.5};
```
**원을 표현하는 객체**
```javascript
var circle = {
    center: { x: 1.0, y: 2.0}, // 원의 중점을 표현하는 객체
    radius: 2.5                // 반지름
}
```

메서드
------
프로퍼티에 저장된 값의 타입이 함수면 그 프로퍼티를 메서드라고 부른다.

객체는 참조 타입
------
객체 타입의 값을 변수에 대입하면 그 변수에는 객체의 **참조**(메모리에서의 위치 정보)가 저장된다. 이때의 변수 상태를 가리켜 그 객체를 **참조하고 있다**라고 한다.<br/>
변수에 저장된 객체의 참조는 다른 원시 값과 마찬가지로 다른 변수에 저장할 수 있다.
```javascript
var a = card;
```
그러면 변수 a가 card 객체를 참조하게 되므로 a로 card 객체를 읽거나 수정할 수 있다.
```javascript
console.log(a.suit);    // 하트
a.suit = "스페이드";
console.log(a.suit);    // 스페이드
console.log(card.suit); // 스페이드
```
<br/>

함수의 기초
======
함수는 자바스크립트 프로그래밍 언어를 규정하는 가장 중요한 구성 요소이다.

함수
------
자바스크립트에서 함수는 일련의 처리를 하나로 모아 언제든 호출할 수 있도록 만들어 둔 것이다. 입력값을 받으면 출력 값으로 함수 값을 반환한다. 자바스크립트에서 함수의 입력 값을 **인수**라고 부르고 함수의 출력 값을 **반환값**이라고 부른다.

함수 선언문으로 함수 정의하기
------
함수는 function 키워드를 사용해서 정의한다.
```javascript
function square(x) { return x*x; }
```

함수 이름
------
변수 이름과 마찬가지로 모든 식별자를 함수 이름으로 사용할 수 있다. 그러나 함수 이름은 해당 함수의 기능을 이해하기 쉽게 지어야 한다.

함수 호출
------
함수를 호출하려면 함수 이름 뒤에 소괄호로 인수를 묶어 입력한다.
```javascript
square(3) // 9
```
함수를 호출할 때 전달하는 값을 **인수**(argument), 함수 정의문의 인수를 **인자**(parameter)라고 한다.

인수
------
함수는 인수를 여러 개 받을 수 있다. 인수가 여러 개라면 인수와 인수를 쉼표(,)로 구분한다. 예를 들어 다음 함수 dist는 두 점 사이의 거리를 구하는 함수이다.
```javascript
function dist(p,q){
    var dx = q.x - p.x;
    var dy = q.y - p.y;
    return Math.sqrt(dx*dx+dy*dy);
}

var p1 = {x:1, y:1};
var p2 = {x:4, y:5};
var d = dist(p1,p2); //5
```

인수를 받지 않는 함수도 정의할 수 있다.
```javascript
var bark = function() { console.log("Bow-wow"); };
bark(); // "Bow-wow"
```
bark 함수에는 인수도 없고 return 문도 없다. return 문이 실행되지 않은 상태에서 제어권이 함수를 호출한 코드로 되돌아가면 함수의 반환값이 undefined가 된다.
```javascript
console.log(bark()); // undefined
```

함수의 실행 흐름
------
　• 호출한 코드에 있는 인수가 함수 정의문의 인자에 대입된다.<br/>
　• 함수 정의문의 중괄호 안에 작성된 프로그램이 순차적으로 실행된다.<br/>
　• return 문이 실행되면 호출한 코드로 돌아간다. return 문의 값은 함수의 반환값이 된다.<br/>
　• return 문이 실행되지 않은 상태로 마지막 문장이 실행되면, 호출한 코드로 돌아간 후에 undefined가 함수의 반환값이 된다.<br/>

함수 선언문의 끌어올림
------
자바스크립트 엔진은 변수 선언문과 마찬가지로 함수 선언문을 프로그램의 첫머리로 끌어올린다. 함수 선언문은 프로그램의 어떤 위치에도 작성할 수 있다.
```javascript
console.log(square(5)); // 25
function square(x) { return x * x; }
```

값으로서의 함수
------
자바스크립트에서는 함수가 객체이다. 함수 선언문으로 함수를 선언하면 내부적으로는 그 함수 이름을 변수 이름으로 한 변수와 함수 객체가 만들어지고, 그 변수에 함수 객체의 참조가 저장된다. 이 변수 값을 다른 변수에 할당하면 그 변수 이름으로 함수를 실행할 수 있다.
```javascript
var sq = square;
console.log(sq(5)); // 25
```

참조에 의한 호출과 값에 의한 호출
------
함수는 원시 값을 인수로 넘겼을 때와 객체를 인수로 넘겼을 때 다르게 동작한다. 먼저 인수가 원시 값일 때 어떻게 동작하는지 예제를 살펴본다.
```javascript
function add1(x) { return x = x + 1; }
var a = 3;
var b = add1(a);
console.log("a = " + a + ", b = " + b); // a = 3, b = 4
```
add1은 전달받은 인수에 1을 더하여 반환하는 함수이다. 이 함수가 호출될 때 변수 a의 복사본이 인자 x에 할당된다. 즉, 인수에 원시 값을 넘기면 그 값 자체가 인자에 전달된다. 이르 가리켜 **값의 전달**이라고 부른다. 이때 변수 a와 변수 x는 다른 영역의 메모리에 위치한 별개의 변수이다. 따라서 x 값을 바꾸더라고 a 값은 바뀌지 않는다. <br/>
다음으로 인수가 객체일 때 어떻게 동작하는지 예제를 살펴본다.
```javascript
function add1(p) { p.x = p.x + 1; p.y = p.y + 1; return p; }
var a = {x:3, y:4};
var b = add1(a);
console.log(a, b); // Object {x=4, y=5} Object {x=4, y=5}
```
이번에 등장한 add1 함수는 2차원 좌표의 각 성분에 1을 더한 좌표를 반환하는 함수이다. 함수가 호출될 때 변수 a의 복사본이 인자 p에 할당된다. 여기까지는 원시 값을 인수로 넘겼을 때와 동일하게 동작하지만 이전과 다르게 변수 a에 객체 {x:3, y:4}의 참조가 저장되어 있으며, 이 참조 값을 인자 p에 대입한다. 즉, 인수로 넘겼을 때 전달되는 값은 참조 값이다. 이를 가리켜 **참조 전달**이라고부른다.<br/>
**인수 여러 개를 우아하게 전달하는 방법(elegant way)**<br/>
함수에 넘겨야 하는 인수 개수가 많아지면 다음과 같은 문제가 발생한다.<br/>
　• 인수의 순서를 착각하기 쉽다.<br/>
　• 함수가 받는 인수 개수를 바꾸면 함수의 호출 방법이 바뀌므로 프로그램 전체를 수정해야 한다.<br/>
객체의 프로퍼티에 인수를 담아서 넘기면 이러한 문제를 우아하게 해결할 수 있다. 다음과 같이 인수가 많은 함수를 예로 들어본다.
```javascript
function setBallProperties(x, y, vx, vy, radius) { ... }
...
setBallProperties(0, 0, 10, 15, 5);
```
이 함수의 인수를 다음과 같이 객체의 프로퍼티에 담아서 함수에 넘기도록 고쳐 본다.
```javascript
var parameters = {
    x: 0,
    y: 0,
    vx: 10,
    vy: 15,
    radius: 5,
    color: "blue"
};
setBallProperties(parameters);
```
단, 함수 안에서 객체릐 프로퍼티를 수저아면 호출한 코드에 있는 객체의 프로퍼티가 함께 바뀌므로 주의해야 한다. 객체를 인수로 넘기면 함수에는 객체의 참조가 전달되기 때문이다.

변수의 유효 범위
------
**전역 유효 범위와 지역 유효 범위**<br/>
변수에 접근할 수 있는 범위를 그 변수의 **유효 범위**(scope)라고 한다. 유효 범위를 결정하는 방법에는 프로그램의 구문만으로 유효 범위를 정하는 **어휘적 범위**(lexical scope)와 프로그램 실행 중에 범위를 정하는 **동적 범위**(dynamic scope)이 있다. 자바스크립트의 변수는 **전역 변수**와 **지역 변수**가 있다. 전역 변수는 함수 바깥에서 선언된 변수로 유료 범위가 전체 프로그램이고 지역번수는 함수안에서 선언된 변수와 함수 인자로 유효 범위는 변수가 선언된 함수 내부이다.<br/>
**변수의 충돌**<br/>
변수에 유효 범위가 있는 이류는 프로그램의 다른 부분에서 선언된 이름이 같은 변수와 충돌하지 않도록 하기 위해서이다.<br/>
**함수 안에서의 변수 선언과 변수 끌어올림**<br/>
함수 안에서 선언된 지역 변수의 유효 범위는 함수 전체이다. 함수 중간 부분에서 변수를 선언하더라도 변수는 함수 첫머리에서 선언된 것처럼 함수 안의 다를 문장보다 먼저 생성된다.<br/>
**함수 안에서의 변수 선언 생략**<br/>
변수를 선언하지 안은 상태에서 값을 대입하면 전역 변수로 선언된다.

블록 유효 범위 : let과 const
------
let과 const는 ECMASript 6부터 추가된 변수 선언자로 모두가 '블록 유효 범위'를 갖는 변수를 선언한다. 블록 유효 범위를 가진 변수는 중괄호({}) 안에서만 유효하다. let은 변수를 선언하고 const는 한 번만 할당할 수 있는 상수를 선언한다.<br/>
**let 선언자**<br/>
let 문은 블록 유효 범위를 작는 지역 변수를 선언한다. 사용법은 var 문과 같다.
```javascript
let x;
let a, b, c;
let x = 5, y = 7;
```
var로 선언한 변수와 let으로 선언한 변수의 가장 큰 차이점은 let으로 선언한 변수의 유효 범위가 블록 안이라는 점이다.<br/>
**const 선언자**<br/>
const 문은 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다. const로 선언한 상수는 let 문으로 선언한 변수처럼 동작한다. 단, 반드시 초기화해야 한다는 차이점이 있다.
```javascript
const c = 2;
// c = 5; const 문으로 선언한 변수에 다시 대입을 시도하면 타입오류가 발생한다.
const origin = {x:1, y:2}; // const 문으로 선언한 상수 값이 객체이거나 배열일 경우에는 프로퍼티 또는 프로퍼티 값을 수정할 수 있다.
origin.x = 3;
console.log(origin) // Object {x:3, y:2}
```

함수 리터럴로 함수 정의하기
------
함수는 함수 리터럴로도 정의할 수 있다. 예를 들어 앞에서 예로 들었던 함수 square는 다음과 같이 함수 리터럴로 수정할 수 있다.
```javascript
var square = function(x) { return x * x; };
```
이 코드에서는 function(x) {...} 부분이 함수 리터럴이다. **함수 리터럴**은 이름이 없는 함수이므로 **익명 함수** 또는 **무명 함수**라고 부른다. 함수 선언문에서는 끝에 세미클론을 붙일 필요가 없지만 함수 리터럴을 사용할 때는 끝에 반드시 세미클론을 붙어야 한다. 함수 선언문으로 정의한 함수와 함수 리터럴로 정의한 함수 사용법은 같다. square(5)라고 작성하면 함수를 실행할 수 있다. 한 가지 차이점이라면 자바스크립트 엔진이 함수 선언문으로 정의한 함수는 끌어올리지만 함수 리터럴로 정의한 함수는 끌어올리지 않는다는 점이다.<br/>
익명 함수에도 이름을 붙일 수 있다.
```javascript
var square = function sq(x) { return x * x; };
```
그러나 코드에서 sq라는 아름은 함수 안에서만 유효하므로 함수 바깥에서는 sq라는 이름으로 함수를 호출할 수 없다.

객체의 메서드
------
객체의 프로퍼티 중에서 함수 객체의 참조를 값으로 담고 있는 프로퍼티를 가리켜 메서드라고 부른다. 메서드를 정의할 때는 프로퍼티 값으로 함수 리터럴을 대입한다. 예를 들어 원을 그리는 객체에 원의 넓이를 구하는 메서드인 area를 추가할 수 있다.
```javascript
var circle = {
    center: { x:1.0, y:2.0 }, // 원의 중점을 표현하는 객체
    radius: 2.5,              // 원의 반지름
    area: function () {       // 원의 넓이를 구하는 메서드
        return Math.PI * this.radius * this.radius;
    }
};
```
함수 객체 안에 적힌 this는 그 함수를 메서드로 가지고 있는 객체를 가리킨다. 메서드는 일반 함수와 마찬가지로 소괄호를 붙여서 실행한다.
```javascript
circle.area() // 19.634954084936208
```
매서드 또한 프로퍼티의 일종이므로 나중에 추가할 수 있다. 예를 들어 객체 circle에 원을 평행으로 이동시키는 translate 메서드를 추가할 수 있다.
```javascript
circle.translate = function(a, b) {
    this.center.x = this.center.x + a;
    this.center.y = this.center.y + b;
};
```
이 메서드를 실행하면 다음과 같은 결과가 나온다.
```javascript
circle.translate(1, 2);
circle.center;  // Object { x=2, y=4} 
```
이 예에서 알 수 있듯이 메서드는 일반적으로 메서드가 속한 객체의 내부 데이터(프로퍼티 값) 상태를 바꾸는 용도로 사용한다. 이러한 객체를 기본 부품으로 삼아 프로그램을 만들어 가는 기법을 가리켜 객체 지향 프로그래밍이라고 부른다.

함수를 활용하면 얻을 수 있는 장점
------
함수를 활용하면 다양한 효과를 기대할 수 있다.<br/>
**재사용할 수 있다**<br/>
같은 코드를 여러 번 작성할 필요가 없어지므로 프로그램이 간결해진다.<br/>
**만든 프로그램을 이해하기 쉽다**<br/>
함수를 사용하면 일정한 처리를 모아서 이름을 붙일 수 있다. 이는 함수 안에 상세한 내용을 숨기는 효과가 있다.<br/>
**프로그램 수정이 간단해진다**<br/>
함수로 정리해 두면 해당 함수만 수정하면되므로 수정이 간단해진다.

객체의 기초 ② 생성자
======
이 절에서는 생성자로 객체를 생성하는 방법을 배운다.

생성자로 객체 생성하기
------
자바스크립트에는 클래스가 없지만 생성자라고 하는 함수로 객체를 생성할 수 있다.<br/>
**간단한 예**<br/>
다음 코드는 트럼프 카드를 표현하는 객체를 생성하는 생성자이다.
```javascript
function Card(suit, rank) {
    this.suit = suit;
    this.rank = rank;
}
```
생성자로 객체를 생성할 때는 **new 연산자**를 사용한다.
```javascript
var card = new Card("하트", "A");
```
이 코드를 실행하면 suit 프로퍼티에는 "하트", rank 프로퍼티에는 "A"라는 값이 저장된 객체다 생성되고, 마지막으로 그 객체의 참조가 변수 card에 할당된다.
```javascript
console.log(card); // Card {suit: "하트", rank: "A"}
```
이때 Card 생성자로 생성한 객체를 Card 객체라고 부른다. console.log로 객체를 출력하면 앞에 생성자 이름이 표시된다.<br/>
**생성자**<br/>
new 연산자로 객체를 생성할 것이라 기대하고 만든 함수를 생성자라고 부른다. 생성자 이름은 관례적으로 그것이 생성자임을 알리기 위해 첫 글자를 대문자로 쓴다. 생성자 안에서 **this.프로퍼티 이름**에 값을 대입하면 그 이름을 가진 프로퍼티에 값이 할당된 객체가 생성된다. 앞의 예는 다음과 같이 객체 리터럴로 고쳐 쓸 수 있다.
```javascript
var card = {};
card.suit = "하트";
card.rank = "A";
```
생성자와 new 연산자로 생성한 객체를 그 생성자의 **인스턴스(실체)**라고 부른다.<br/>
**생성자릐 역할**<br/>
생성자는 객체를 생성하고 초기화하는 역할을 한다. 생성자를 사용하면 이름은 같지만 프로퍼티 값이 다른 객체(인스턴스) 여러 개를 간단히 생성할 수 있다.
```javascript
var card1 = new Card("하트", "A");
var card2 = new Card("클럽", "K");
var card3 = new Card("스페이드", "2");
```
이처럼 생성자를 사용하면 이름이 같지만 프로퍼티 값이 다른 객체 여러 개를 효율적으로 생성할 수 있다.<br/>
생성자는 함수이므로 프로퍼티에 값을 대입할 수 있다. 다른 함수와 마찬가지로 다양한 처리를 할 수도 있다. 이를 활용하면 객체를 생성할 때 초기화 작업을 병행할 수 있다. 

매서드를 가진 객체를 생성하는 생성자
------
생성자에서 **this.프로퍼티 이름**에 함수의 참조를 대입하면 메서드를 정의할 수 있다.
```javascript
function Circle(center, radius) {
    this.center = center;
    this.radius = radius;
    this.area = function() {
      return Math.PI * this.radius * this.radius;
    };
}
var p = {x:0, y:0};
var c = new Circle(p, 2.0);
console.log("넓이 = " + c.area()); // 넓이 = 12.566370614359172
```

객체의 기초 ③ 내장 객체
======
자바스크립트에는 처음부터 사용할 수 있는 내장 객체(빝트이 오브젝트)가 마련되어있다. 내장 객체는 자바스크립트라는 프로그래밍 언어의 뻐대를 구성한다.

내장 생성자
------
자바스크립트에서 사용할 수 있는 생성자에는 사용자가 정의하는 생성자 외에도 자바스크립트에 처음부터 포함된 '내장 생성자'가 있다. 내장 생성자에는 이미 유용한 프로퍼티와 메서드가 마련되어 있으므로 내장 생성자를 이용하여 객체를 생성하면 다양한 작업을 쉽게 처리할 수 있다.

Date 생성자
------
Date 생성자는 날짜와 시간을 표현하는 객체를 생성한다. Date 객체에 내장된 다양한 메서드를 활용하면 날짜와 시간 처리를 간단하게 할 수 있다. Date 객체는 Date 생성자로 생성한다.
```javascript
var now = new Date(); // 실행한 시점의 날짜와 시간 정보를 담은 객체 생성
console.log(now);     // Date {Tue Aug 01 2017 09:41:54 GMT+0900 (KST)}
```
Date 생성자의 인수로 날짜와 시간을 전달하면 그 날짜와 시간을 가라키는 Date 객체가 생성되고 Date 객체는 계산식 안에서 밀리초 단위 정수로 값의 타입이 바뀐다.
```javascript
var then = new Date(2008, 5, 10);
console.log(then); // Date {Tue Jun 10 2008 00:00:00 GMT+0900 (KST)}

var elapsed = now - then;
console.log(elapsed); // 245177916548
```
이 성질을 활용하면 프로그램 실행에 걸리는 시간을 밀리초 단위로 구할 수 있다.
```javascript
var start = new Date();
var end = new Date();
var elapsed = end - start; // 프로그램 실행에 걸리는 시간(밀리초 단위)
```
다음은 Date 객체가 제공하는 주요 메서드이다.
```javascript
now.getFullYear()         // 2016(연도를 뜻하는 숫자 값)
now.getMonth()            // 4(월을 뜻하는 숫자 값. 0부터 시작하므로 이 경우에는 5월을 뜻함)
now.getDate()             // 17(날짜를 뜻하는 숫자 값)
now.getDay()              // 4(요일을 뜻하는 숫자 값. 일요일이 0이므로 이 경우에는 목요일을 뜻함)
now.getHours()            // 16(시각의 시간을 뜻하는 숫자 값)
now.getMinutes()          // 50(시각의 분을 뜻하는 숫자 값)
now.getSeconds()          // 55(시각의 초를 뜻하는 숫자 값)
now.getMilliseconds()     // 257(시각의 밀리초를 뜻하는 숫자 값)
now.toString()            // "The Mar 17 2016 16:50:55 GMT+0900(KST)"
now.toLocaleString()      // "2016/3/17 16:50:55" (지역화된 시간과 날짜 정보)
now.toLocaleDateString()  // "2016. 3. 17." (지역화된 날짜 정보)
now.toLocaleTimeSting()   // "오후 4:50:55" (지역화된 시간 정보)
now.getUTCHours()         // 7(UTC(협정 세계 시) 시각의 시간을 뜻하는 숫자 값)
now.toUTCString()         // "Sun, 17 Apr 2016 07:50:55 GMT" (UTC 시각과 날짜 정보)
```

Function 생성자
------
Function은 함수를 생성하는 내장 생성자이다.
```javascript
var square = new Function("x", "return x * x");
```
이때 첫 번째 인자인 "x"는 인수의 이름을 뜻하는 문자열이고 두 번째 인수는 함수 몸통(function body)이 작성된 문자열이다. 일반적으로 인수가 n개일 때는 다음과 같이 사용한다.
```javascript
var 변수 이름 = new Function(첫 번째 인수, ... , n번째 인수, 함수 몸통); 
```
Function 생성자로 생성한 함수는 전역 변수와 자신의 지역 변수만 읽고 쓸 수 있다는 단점이 있어서 함수를 동적으로 생성해야 하는 특별한 상황 외에는 사용하지 않는다. 또한 악의를 품은 사용자가 입력한 문자열을 Function 생성자의 인수인 '함수의 몸통'으로 전달하면 악성 코드가 실행되어 보안 문제가 발생할 수도 있다.

기타 내장 객체
------
자바스크립트에서는 처음부터 사용할 수 있는 객체를 가리켜 **내장 객체**(빌트인 오브젝트)라고 부르며, 앞서 설명한 내장 생성자가 내장 객체를 생성한다.<br/>

|내장 객체|설명|
|:---:|---|
|전역 객체|프로그램 어디에서나 사용할 수 있는 객체|
|JSON|JSON을 처리하는 기능을 제공|
|MATH|수학적인 함수와 상수를 제공|
|Reflect|프로그램으 흐름을 가로채는 기능을 제공|

전역 객체
------
전역 객체의 프로퍼티는 프로그램의 어느 위치에서나 사용할 수 있다.

|분류|프로퍼티|
|:---:|---|
|전역 프로퍼티|undefined, NaN, Infinity|
|생성자|Object(),String(), Number() 등|
|전역 함수|parseInt(), parseFloat(), isNaN() 등|
|내장 객체|Math, JSON, Reflect|

자바스크립트 객체의 분류
------
자바스크립트 객체는 크게 네이티브 객체, 호스트 객체, 사용자 정의 객체로 나눌 수 있다.<br/>
**네이티브 객체**<br/>
ECMAScript 사양에 정의된 객체가 네이티브 객체(native object)이다. 내장 생성자로 생성된 객체와 JSON, Math, Reflect 등이 네이티브 객체이다.<br/>
**호스트 객체**<br/>
ECMAScript에는 정의되어 있지 않지만 자바스크립트 실행 환경에 정의된 객체가 호스트 객체(host object)이다. 브라우저 객체, DOM에 정의되어 있는 객체, Ajax를 위한 XMLHttpRequest 객체, HTML5의 각종 API 등이 클라이언트 측 자바스크립트에 정의된 호스트 객체의 예이다.<br/> 
**사용자 정의 객체**<br/>
사용자가 정의한 자바스크립트 코드를 실행한 결과로 생성된 객체가 사용자 정의 객체이다.<br/>

배열의 기초
======
배열은 값의 목록으로 값마다 번호가 매겨져 있다. 배열을 활용하면 다양한 알고리즘을 표한할 수 있다.<br/>

배열 리터럴로 생성하기
------
배열 리터럴은 쉼표로 구분한 값을 대괄호([])로 묶어서 표현한다.
```javascript
var evens = [ 2, 4, 6, 8 ];
```
위 코드에서 [...] 부분이 배열 리터럴이며 배열 값 하나를 배열 요소라고 부른다. **배열 요소**에는 왼쪽부터 순서대로 0, 1, 2 ... 라는 번호가 매겨져 있다. 요소에 매긴 번호는 **요소 번호** 또는 **인덱스**라고 부른다.
```javascript
var empty = [];     // 배열 리터럴 안에 어떠한 요소도 작성하지 않으면 빈 배열이 생선된다.
console.log(empty); // []

var a = [2, , 4];   // 배열 리터럴 요소의 값을 생략하면 그 요소는 생성되지 않는다.
console.log(a);     // [ 2, undefined, 4]

var various = [ 3.14, "pi", true, {x:1, y:2}, [2, 4, 6, 8] ]; // 배열의 요소에는 변수와 마찬가지로 모든 타입의 값이 올 수 있다.
```

length 프로퍼티
------
배열의 length 프로퍼티에는 **배열 요소의 쵀대 인덱스 값 +1**이 담겨 있다.
```javascript
var evens = [ 2, 4, 6, 8 ];
evens.length // 4
```
length 프로퍼티 값을 가리켜 **배열 길이**라고 부른다. 자바스크립트에서는 배열 길이가 배열 요소의 개수를 뜻하지 않는 경우가 있으므로 주의해야 한다.<br/>
length 프로퍼티에 현재의 배열 요소 개수보다 작고 0보다 큰 정수 값을 대입하면 배열 길이가 줄어든다.
```javascript
var a = ["A", "B", "C", "D"];
a.length = 2;
console.log(a); // ["A", "B"]
```

Array 생성자로 생성하기
------
배열은 Array 생성자로도 생성할 수 있다.
```javascript
var evens = new Array(2, 4, 6, 8);  // [ 2, 4, 6, 8 ]을 생성
var empty = new Array();            // 빈 배열 []을 생성
var a = new Array(2, 4);            // 배열 리터럴 [2, 4]와 똑같은 비열을 생성
var various = new Array(3.14, "pi", true, {x:1, y:2}, [2, 4, 6, 8]);
```
Array 생성자의 인수가 한 개고 그 값이 양의 정수면 의미가 달라진다. 이때 인수는 배열 길이를 뜻하므로 배열이 그 길이만큼 생성된다.
```javascript
var x = new Array(3);
console.log(x.length); // 3
```

배열 요소의 참조
------
특정 인덱스의 요소는 대괄호([]) 연산자를 사용해서 읽거나 쓸 수 있다.
```javascript
evens[2] // 6
```

배열은 객체
------
자바스크립트의 배열은 Array 객체이며 객체로 배열의 기능을 가상으로 흉내 낸 것이다. 배열에 대괄호 연산자를 사용하는 것은 객체에 대괄호 연산자를 사용하는 것과 마찬가지이며, 배열의 요소 번호로 숫자 값 대신 문자열을 사용할 수 있다.
```javascript
var a = ["A", "B", "C", "D"];
console.log(a["2"]);  // C
a[4]  // undefined, 없는 배열 요소를 읽으려고 시도하면 undefined가 반환된다.
```
참고로 ECMAScript 6부터는 TypedArray 객체가 추가되어 C나 Java 등의 배열과 마찬가지로 메모리의 연속된 공간에 차례대로 배치된다.

배열 요소의 추가와 삭제
------
없는 배열 요소에 값을 대입하면 새로운 요소가 추가되고 push 메서드를 사용하면 요소를 배열 끝에 추가할 수 있다. delete 연산자를 사용하면 특정 배열 요소를 삭제할 수 있다.
```javascript
var a = ["A", "B", "C"];
a[3] = "D";
console.log(a); // ["A", "B", "C", "D"]

var b = ["A", "B", "C"];
b.push("D");
console.log(b); // ["A", "B", "C", "D"]

delete a[1];
console.log(a); // ["A", undefined, "C", "D"]
```
delete 연산자를 사용하여 배열의 요소를 삭제해도 그 배열의 length 프로퍼티 값은 바뀌지 않고 삭제한 요소만 사라진다.

희소 배열
------
배열에 요소를 추가하거나 제거하면 인덱스가 0부터 시작되지 않는 배열이 만들어진다. 이러한 배열을 **희소 배열**이라고 부른다.
```javascript
var a = ["A", "B", "C"];
a[4] = "E";
console.log(a); // ["A", "B", "C", undefined, "E"]
```
위 코드를 실행하여 결과를 보면 a[3]이 undefined라고 표시되지만 실제로 저 요소는 없다.


# 5장
연산자
======
프로그래밍에는 +나 * 등의 연산자를 사용하여 다양한 계산을 한다.

표현식과 연산자
------
표현식이란 결과적으로 어떤 값으로 평가(evaluation)되는 것이다. 이 말은 표현식의 값과 변수, 함수 등의 값을 바탕으로 식의 값을 계산하는 행위를 뜻한다.
```javascript
3.14, "hello", true, false, null // 가장 간단한 표현식은 숫자, 문자열, 논리값 등의 원시 값(Primitive values)이다.
sum, circle.radius, a[3], square(5), card.getSum() // 변수, 프로퍼티, 배열 요소, 함수 호출, 메서드 호출도 표현식이다.
```
**연산자**(오퍼레이터, operator)를 사용하면 표현식을 조합혀여 더욱 복잡한 표현식을 만들어 낼 수 있다.
```javascript
a + b
```
이 코드에서 +부분이 연산자이고 a와 b 부분은 연산 대상이 되는 **피연산자**(오퍼랜드, operand)라고 부른다. 연산자는 일반적으로 피연산자 개수에 따라 단항 연산자, 이항 연산자, 삼항 연산자로 분류한다. + 연산자의 왼쪽과 오른쪽에는 피연산자가 총 두 개 있으므로 이항 연산자라고 부르고 -x의 - 연산자는 오른쪽에 피연산자 x 하나만 있으므로 단항 연산자이다. 삼항 연산자는 ?:뿐이다.

연산자의 우선순위
------
연산자가 여러 개 있을 때는 계산 순서에 따라 결과가 달라진다. 연산자에는 우선순위라는 것이 정해져 있고 우선순위에 따라 연산 순서가 정해진다.

연산자 결합 법칙
------
연산은 연산자 우선순위에 따라 진행되지만, 우선순위가 같은 연산자가 나열되어 있으면 연산 순서를 연산자 우선순위만으로는 결정할 수 없다. 이럴 때는 왼쪽과 오른쪽의 어떤 연산자와 결합해서 연산하는지에 따라 결과가 달라진다.
```javascript
24 / 6 * 2
```
연산자에는 왼쪽과 결합해서 연산할지 아니면 오른쪽과 결합해서 연산할지를 결정하는 **결합 법칙**이 정해져 있다. 위 경우는 왼쪽에서 오른쪽 방향으로 결합한다.

연산자의 부수 효과
------
변수 값을 바꾸는 표현식을 일반적으로 **부수 효과가 있는 표현식**이라고 한다. 대입 연산자, 증가 연산자, 감소 연산자, delete가 부수 효과가 있는 연산자이다.

산술 연산
======
이 절에서는 사칙 연산이나 나머지 값 등의 산술 연산을 하는 연산자, 제곱근이나 삼각 함수 등의 수학 함수를 배운다.

산술 연산자
------
산술 연산자는 피연산자가 숫자인 연산자이다.<br/>
**산술 이항 연산자**<br/>
산술 이항 연산자는 +, -, *, /, %가 있다.<br/>
다음은 산술 이항 연산자를 쓸 때 몇 가지 주의할 사항이다.<br/>
① 정수끼리 나누어도 결과가 부동 소수점이 된다.
```javascript
7 / 2 // 3.5
```
② 나머지 연산자 %의 피연산자는 부동소수점이다.
```javascript
15 % 4    // 3
5 % 1.5   // 0.5
```
③ + 연산자는 피연산자 중 하나가 문자열이면 나머지 피연산자를 문자열로 만든다.
```javascript
1 + "2month" // "12month"
```
④기타<br/>
계산할 수 없는 경우에는 NaN으로 평가한다. 또한 산술 연잔자의 피연산자가 true면 1, false와 null이면 0으로 평가한다. undefined면 NaN으로 평가한다.<br/>

**산술 단항 연산자**<br/>

|연산자|뜻|
|:---:|:---:|
|++|증가 연산자|
|--|감소 연산자|
|+|아무것도 처리하지 않음|
|-|부호 반전|

증가 연산자와 감소 연산자는 피연산자가 아에 표기하는 전위 표기법과 뒤에 표기하는 후위 표기법을 사용할 수 있다. 전위 표기법을 사용하면 피연산자 값을 바꾼 다음에 피연산자를 평가하고 후위 표기법을 사용하면 피연산자 값을 평가한 다음에 피연산자 값을 바꾼다.
```javascript
a = 1;
b = ++a;      // b는 2가 되고 a는 2가 된다
c = a++ + 2;  // c는 4가 되고 a는 3이 된다
```

**산술 대입 연산자**<br/>
산술 대입 연산자는 +=, -=, *=, /=, %=이 있다.

Math 객체의 프로퍼티
------
자바스크립트에서는 지금까지 설명한 기본적인 산술 연산과 복잡한 수학적 연산을 지원하며, 이들은 Math 객체의 프로퍼티와 메서드에 포함되어 있다.

부동소수점과 정확도 문제
------
자바스크립트의 숫자는 IEEE754로 규정된 64비트 부동소수점이며, 이는 부호(1비트), 지수 부분(11비트), 가수 부분(52비트)로 64자리수의 2진수 부동소수점을 표현한다.<br/>
숫자를 자리수가 정해진 부동소수점으로 표현하여 계산하면 오차가 발생하는데 이것을 **정확도 문제**라고 한다. 일반적으로 값이 가까운 두 수를 뺄셈할 때 정확도 문제가 발생하는데 이를 **정밀도 손실**이라고 한다. 정밀도 손실을 피하려면 계산 과정을 다시 검토하여 크기가 비슷한 수의 뺄셈을 피하도록 해야 한다.


문자열 제어하기
======
문자열 처리와 산술 연산은 프로그램의 기본적인 데이터 처리이다.

문자열 연결
------
\+ 연산자는 피연산자가 모두 문자열이면 문자열로 연결하고 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼다음 연결한다.
```javascript
"Hello" + "World!"    // "Hello World!"
10 + "little indians" // "10 little indians"
1 + {}                // "1[Object Object]"
true + (new Date())   // "trueTue Sat Aug 05 2017 22:38:59 GMT+0900 (KST)"
```
그렇지 않으면 피연산자 두 개를 숫자 또는 NaN으로 타입을 바꾸어 더한다. 이 경우는 자바스크립트의 실행 환경에 따라 처리하는 방법이 다르다.

문자열을 조작하는 메서드
------
문자열을 처리하기 위한 객체로 String 객체가 있다. 문자열을 String 객체로 변환하려면 String 생성자를 사용한다.
```javascript
var msgObj = new String("Everything is practice.");
```
이처럼 원시 값을 객체로 변환하는 행위를 가리켜 원시 값을 객체로 **래핑**(wrapping)한다고 한다. 예를 들어 문자열의 길이는 배열과 마찬가지로 length 프로퍼티로 구할 수 있다.
```javascript
msgObj.length // 23
```
이때 String 객체로 표시되는 문자열의 각 문자에는 왼쪽부터 순서대로 0부터 시작하는 번호가 매겨진다.

문자열을 배열로 읽고 쓰기
------
문자열을 읽을 떄는 chatAt 메서드 대신 대괄호 연산자를 사용할 수 있다. 그러나 배열처럼 값을 대입해서 수정할 수는 없다.
```javascript
msg[3]            // "r"
msg[msg.length-1] // "."
msg[3] = "R";
cosole.log(msg);  // Everything is practice.
```

논리 연산자와 관계 연산자
======
이 절에서는 논리식(조건식)을 만드는 연산자인 논리 연산자와 관계 연산자를 배운다.

관계 연산자 
------
관계 연산자는 두 개의 피연산자를 비교한 결과를 논리값(true/false)으로 반환한다.

|연산자|뜻|
|:---:|:---:|
|==|값이 같음|
|!=|값이 다름|
|===|값과 타입이 같음|
|!===|값과 타입이 다름|
|<|작음|
|>|큼|
|<=|작거나 같음|
|>=|크거나 같음|

논리 연산자
------

|연산자|뜻|
|:---:|:---:|
|&&|논리곱|
|\|\||논리합|
|!|부정|

비트 연산
======
비트 연산자는 데이터 통신이나 이진 파일을 처리할 때 자주 사용한다.

비트 연산
------
비트 연산이란 2진수 숫자의 자리별 값(비트 값)을 다루는 연산이다. 비트 연산자레는 비트 논리 연산자와 비트 시프트 연산자가 있다.

비트 논리 연산자
------
비트 논리 연산자는 비트 값이 0이면 false, 비트 값이 1이면 true로 평가하는 연산자이다.

|연산자|뜻|
|:---:|:---:|
|&|비트 논리곱(AND)|
|\||비트 논리합(OR)|
|^|비트 배타적 논리합(XOR)|
|~|비트 논리 부정(NOT)|

비트 시프트 연산자
------
비트 시프트 연산자는 정수를 2진수 비트 단위로 오른쪽 또는 왼쪽으로 이동시키는 연산자이다.

|연산자|뜻|
|:---:|:---:|
|\<\<|왼쪽 시프트|
|\>\>|오른쪽 시프트|
|\>\>\>|부호 없는 오른쪽 시프트|

비트 연산의 대입 연산자
------
산술 연산자와 마찬가지로 비트 연산의 대입 연산자를 사용할 수 있다. 연산자로는 &=, |=, ^=, \<\<=, \>\>=, \>\>\>=이 있다.


# 6장
대화상자 표시하기
======
이 절에서는 웹 브라우저에 내장된 대화상자를 활용하여 입출력하는 방법을 배운다. 대화상자는 실제로 프로그래밍을 할 때 자주 사용되는 요소는 아니지만 입출력이 간단하기 때문에 프로그래밍을 학습할 때 자주 활용된다.

대화상자
------
웹 브라우저의 전역 객체인 Window 객체에는 대화상자를 표시하기 위한 메서드가 세 개 있다.

|메서드|설명|
|---|---|
|window.alert|경고 대화상자를 표시|
|window.promt|사용자의 문자열 입력을 받는 대화상자를 표시|
|window.confirm|[확인] 버튼과 [취소] 버튼이 있는 대화상자를 표시|

Window 객체의 메서드는 앞에 붙은 window. 부분을 생략하고 호출할 수 있다.

alert(경고 대화상자)
------
alert 메서드는 경고 대화상자를 표시한다. 인수로는 경고 문자열을 받는다.
```javascript
alert("안녕하세요!");
```
이 코드는 대화상자에서 다음처럼 표시된다.<br/>
<p align="center"><img src="/Week1/img/Modern_Javascript_6_1_1.png" width="400" height="300"></p><br/>
**확인** 버튼을 누르면 대화상자가 사라지고 코드 제어권이 호출한 부분으로 돌아간다.

prompt(입력 대화상자)
------
prompt 메서드는 입력 대화상자를 표시한다. 인수로는 입력을 보조하는 문자열을 받는다.
```javascript
var name= prompt("이름을 입력하십시오");
```
이 코드는 대화상자에서 다음처럼 표시된다.<br/>
<p align="center"><img src="/Week1/img/Modern_Javascript_6_1_2.png" width="400" height="300"></p><br/>
사용자로부터 입력받은 문자열은 prompt 메서드의 변환값이 된다. 두 번째 인수로는 초기 입력 값을 지정할 수 있다. prompt가 반환하는 값은 문자열이지만 숫자 값을 구하려면 parseInt나 parseFloat 메서드를 활용해서 숫자로 바꾼다.

```javascript
var name= prompt("이름을 입력하십시오", "이현규");
var age = parseInt(prompt("나이를 입력하십시오"));
var height = parseFloat(prompt("키를 입력하십시오"));
```
confirm
------
confirm 메서드는 **확인** 버튼과 **취소** 버튼이 있는 확인 대화상자를 표시한다. 인수로는 메시지를 뜻하는 문자열을 받는다.
 ```javascript
var ret = confirm("링크를 표시하시겠습니까?");
```
이 코드는 대화상자에 다음처럼 표시된다.<br/>
<p align="center"><img src="/Week1/img/Modern_Javascript_6_1_3.png" width="400" height="300"></p><br/>

confirm 메서드는 논리값을 반환한다. **확인** 버튼을 누르면 true가 반환되고 **취소** 버튼을 누르면 false가 반환된다.

console
======
이 절에서는 Console 객체의 메서들 콘솔에 값을 출력하는 방법을 배운다.

Console 객체의 메서드
------
지금까지 출력할 때 사용한 console.log()는 Console 객체의 메서드 중 하나이다. Console 객체의 주요 메서드는 다음과 같다.

|메서드|설명|
|---|---|
|console.dir|객체의 대화형 목록을 출력|
|console.error|오류 메세지를 출력|
|console.info|메시지 타입 로그를 출력|
|console.log|일반 로그를 출력|
|console.time|처리 사간 측정용 타이머를 시작|
|console.timeEnd|처리 시간 측정요 타이머를 정지시키고 타이머를 시작한 후에 흐른 시간을 밀로초 단위로 출력|
|console.trace|스택 트레이스를 출력|
|console.warn|경고 메시지를 출력|

콘솔에 텍스트 출력하기
------
문자열이나 변수 값을 콘솔에 로그로 출력하려면 console.log, console.info, console.warn, console.error 메서드를 사용한다. 이들 메서드가 받는 인수와 표시하는 문자열은 같다. 단지 메서드에 따라 로그 시작 부분에 주의 표식을 추가하는 등 로그 스타일이 다를 뿐이다.<br/>
Console 객체의 메서드에는 인수 여러 개를 쉼표로 구분해서 넘실수 있고 값을 한 문자열로 연결해서 인수로 넘기면 공백 문자를 빼고 출력할 수 있다. 또한 서식 문자열을 사용하여 값을 지정된 서식으로 변환해서 출력할 수 있다.
```javascript
var a = [2, 4, 6];
console.log("배열", a, "의 길이는", a.length, "입니다."); // 배열 [2, 4, 6] 의 길이는3 입니다.
console.log("배열" + a + "의 길이는" + a.length + "입니다."); // 배열 2, 4, 6 의 길이는3 입니다.

var name = "Tom";
var height = 172.5;
console.log("그의 이름은 %s 이며 키는 %f cm 입니다", name, height); // 그의 이름은 Tom 이며 키는 172.5 cm 입니다
```
Console 객체의 메서드에는 첫 번째 인수로 받은 문자열 안에 포함되어 있는 서식 문자열을 두 번째 이후 인수의 값으로 바꾸는 기능이 있다.

|서식 문자열|설명|주의사항|
|:---:|---|:---:|
|%o|객체를 가리키는 하이퍼링크로 변환|Node.js는 지원하지 않음|
|%d|정수값으로 변환|Node.js는 지원하지 않음|
|%i|정숫값으로 변환|Node.js는 지원하지 않음|
|%s|문자열로 변환||
|%f|부동소수점 값으로 변환|Node.js는 지원하지 않음|

객체의 프로퍼티를 목록으로 표시하기
------
console.dir 메서드는 객체의 프로퍼티를 나열한다. 인수로는 객체 하나를 받고 파이어폭스를 제외한 주요 웹 브라우저에는 객체의 펼침 상태를 뜻하는 ▶ 마크가 표시된다. ▶를 클릭하면 객체 내부의 프로퍼티를 펼처서 볼 수 있다.
```javascript
var p = {x:1, y:2};
console.dir(p);
```

타이머
------
console.time과 console.timeEnd 메서드를 사용해서 특정 코드의 실행 시간을 측저할 수 있다. console.time 메서드에 타이머 이름을 뜻하는 문자열을 인자로 넘겨 호출한다. 그리고 실행시간을 측정하는 작업이 끝난 후에 console.timeEnd 메서드에 타이머 이름을 인수로 넘겨서 호출한다. 그러면 처리에 소요된 시간이 밀리초 단위로 표시된다.
```javascript
console.time("answer_time");
alert("확인 버튼을 누르십시오"); //실행 시간을 측정하는 작업
console.timeEnd("answer_time");  // answer_time: 1216.106ms
```

이벤트 처리기 등록하기와 타이머 알아보기
======
이 절에서는 웹 브라우저에서의 입출력을 잠시 뒤로 하고 이벤트 처리기를 등록하는 방법과 타이머를 배운다. 이벤트 처리기를 등록하는 방법과 다음절에서 설명하는 'HTML 요소를 동적으로 읽고 쓰기'를 익히면 CUI(그래픽 유저 인터페이스)를 갖춘 대화형 프로그램을 만들 수 있다. 또한 타이머를 활용하면 슬라이드 쇼나 애니메이션처럼 일정 시간마다 동작을 반복하는 처리를 구현할 수 있다.

이벤트 처리기
------
웹 브라우저에서 동작하는 프로그램은 기본적으로 **이벤트 주도형 프로그램**(event driven program)이다. 이벤트란 사용자가 버튼을 클릭하는 행위처럼 단말기와 애플리케리션이 처리할 수 있는 동작이나 사건을 뜻한다. 이벤트 주도형 프로그램이란 **이벤트가 발생할 때까지 기다렸다가 이벤트가 발생했을 때 미리 등록해 둔 작업을 수행**하는 프로그램을 말한다.<br/>
이벤트 처리기란 이벤트가 발생했을 때 실행되는 함수를 말한다. 함수를 이벤트가 발생했을 때 동작할 이벤트 처리기로 설정하는 행위를 가리켜 '함수를 이벤트의 이벤트 처리기로 등록'한다고 한다. 함수를 이벤트 처리기로 등록하는 방법은 세 가지이다.<br/>
**　① HTML 요소의 속성으로 등록하는 방법**<br/>
**　② DOM 요소의 프로퍼티로 등록하는 방법**<br/>
**　③ addEventListener 메서드를 사용하는 방법**<br/>

HTML 요소의 속성에 이벤트 처리기 등록하기
------
HTML 요소에 이벤트 처리기 속성을 설정하면 그 요소에 이벤트가 발생했을 때 동작하는 이벤트 처리기를 등록할 수 있다. 먼저 click 버튼을 클릭하면 콘솔에 현재 시각을 표시하는 예제를 살펴보자.
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>시각을 콘솔에 표시하기</title>
    <script>
        function displayTime(){
            var d = new Date();
            console.log("현재 시각은 " + d.toLocaleString() + "입니다.");
        }
    </script>
</head>
<body>
    <input type="button" value="click" onclick="displayTime()">
</body>
</html>
```
실행결과<br/>
<p align="center"><img src="/Week1/img/Modern_Javascript_6_3_1.png" width="400" height="300"></p><br/>
이 예제에서 이벤트 처리기는 다음 HTML 요소에 등록되어 있다.
```html
<input type="button" value="click" onclick="displayTime()">
```
여기서 onclick 부분을 **이벤트 처리기 이름**이라고 하며, 이벤트 처리기 이름은 곧 이벤트 유형을 뜻한다.

DOM에서 가져온 HTML 요소에 이벤트 처리기 지정하기
------
DOM(Document Object Model)은 자바스크립트 등의 프로그램이 HTML 요소를 조작할 수 있게하는 인터페이스이다.<br/>
**DOM 객체**
DOM에서는 HTML 문서나 HTML 요소를 가리키는 객체로 자바스크립트를 사용하여 HTML문서를 조작한다. DOM의 주요 객체는 다음과 같이 분류할 수 있다.

|DOM 객체|설명|
|:---:|---|
|window|Window 객체라고 부르며 웹 브라우저 윈도우 하나 또는 탭 하나를 가리킨다.|
|document|Document 객체라고 부르며 HTML 문서 전체를 가리킨다. HTML 문서에서 HTML 요소 객체를 가져오거나 HTML 요소를 새로 만드는 등 HTML 문서 전반에 걸친 기능을 제공한다.|
|요소 객체|HTML 문서의 요소를 가리키는 객체이다.|

**DOM을 사용해서 이벤트 처리기 등록하기**
다음 방법은 DOM을 사용하여 이벤트 처리기를 등록하는 전형적인 방법이다.<br/>
**　① window.onload를 사용하여 HTML 문서를 다 읽어 들인 후에 ②와 ③을 실행한다.**<br/>
**　② document.getElementById 메서드를 사용하여 특정 id 속성 값을 가진 HTML 요소의 요소 객체를 가져온다.**<br/>
**　③ 요소 객체의 이벤트 처리기 프로퍼티에 이벤트 처리기로 동작할 함수를 등록한다.**<br/>
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>시각을 콘솔에 표시하기</title>
    <script>
        function displayTime(){
            var d = new Date();
            console.log("현재 시각은 " + d.toLocaleString() + "입니다.");
        }
        // ① Window 객체의 onload 프로퍼티에 함수를 저장한다.
        // 이 함수는 웹 브라우저가 문서를 모두 읽어 들인 후에 실행된다
        window.onload = function(){
          // ② input 요소의 객체 가져오기
          var button = document.getElementById("button");
          // ③ input 요소를 클릭했을 때 동작하는 이벤트 처리기를 등록한다
          button.onclick = displayTime;
        };
    </script>
</head>
<body>
    <input type="button" value="click" id="button">
</body>
</html>
```

타이머
------
웹 브라우저의 window 객체에는 setTimeout과 setInterval 메서드가 있다. 이들 메서드를 활용하면 지정된 시간이 흐른 후에 함수를 실행하거나 일정한 시간 간격에 따라 함수를 반복 실핼할 수 있다.

**지정된 시간이 흐른 후에 함수 실행하기 : setTimeout**<br/>
setTimeout 메서드를 사용하면 일정 시간이 흐른 후에 한 번만 호출되는 함수를 등록할 수 있다.
```javascript
setTimeout(function(){
    console.log(new Date());
},2000);
```
이 코드를 실행하면 콘솔에 2초후에 날짜가 표시된다. setTimeout 메서드의 첫 번째 인수로는 '실행하고자 하는 함수의 참조', 두 번째 인수로는 '지연 시간'을 밀리초 단위로 지정한다. 또한 setTimeout()이 반환한 값을 cleatTimeout()의 인수로 넘겨서 실행하면 함수 실행이 취소된다.
```javascript
setTimeout(function() {...}, 2000);
...
clearTimeout(timer);
```

**지정된 시간마다 반복해서 실행하기 : setInterval**<br/>
setInterval 메서드를 활용하면 일정한 시간 간격에 따라 반복해서 실행할 함수를 등록할 수 있다.
```javascript
setInterval(function() {
    console.log(new Date());
},1000);
```
이 코드를 실행하면 1초마다 날짜가 콘솔에 표시된다. setInterval 메서드의 첫 번째 인수로는 '실행하고자 하는 함수의 참조', 두 번째 인수로는 '시간 간격'을 밀리초 단위로 설정한다. 또한 setInterval()이 반환한 값을 clearInterval()의 인수로 넘겨서 실행하면 함수 실행이 취소된다.
```javascript
setInterval(function() {...}, 1000);
...
clearInterval(timer);
```
setTimeout()과 setInterval()의 첫 번째 인수로 문자열을 넘길 수도 있다.
```javascript
setInterval("console.log(new Date())", 1000);
```
이때 지정한 문자열은 내부적으로 eval()로 평가된 후에 실행된다.

HTML 요소를 동적으로 읽고 쓰기
======
이제부터는 자바스크립트를 활용해서 HTML 요소 안의 내용을 동적으로 읽고 쓰는 방법을 알아본다. 이 방법을 배우면 HTML의 폼요소 등을 사용자 인터페이스로 삼아 프로그램 입출력을 할 수 있게 된다.

HTML 요소의 innerHTML 프로퍼티로 읽고 쓰기
------
요소 객체의 innerHTML 프로퍼티는 그 HTML 요소의 내용을 기리키며, 이로써 HTML 요소의 내용을 읽거나 쓸 수 있다.

폼 컨트롤의 입력 값 읽기
------

input 요소 등의 폼 컨트롤 요소를 사용하면 사용자의 입력 값을 자바스크립트 프로그램에서 사용할 수 있다.

document.write
------
초창기 자바스크립트에서는 document.write가 처리 결과를 출력하는 유일한 수단이었다. 현재는 앞서 언급한 DOM을 사용하여 HTML 요소를 생성하거나 처리 결과를 HTML 문서로 출력하는 것이 일반적이다.



# 7장
제어 구문
======
문장은 일반적으로 위에서 아래 방향으로 작성한 순서대로 실행되는데 이를 **순차적 실행**이라고 한다. 순차적 실행 흐름을 변화시키는 문장을 **제어 구문**이라고 한다.

|분류|제어 구문|설명|
|:---:|---|---|
|조건문|if/else 문, switch 문, try/catch/finally 문|조건에 따라 처리를 분기|
|반복문|while 문, do/while 문, for 문, for/in 문, for/of 문|조건을 만족하면 처리를 반복 실행|
|점프문|break 문, continue 문, return 문, throw 문|프로그램의 다른 위치로 이동|

조건문
======
조건문은 조건식의 값에 따라 실행 흐름을 분기한다.

if/else 문
------
if/else 문의 사용법은 크게 두가지로 나눌 수 있다.<br/>
`① if (조건식) 문장`<br/>
`② if (조건식) 문장 1 else { 문장 2 }`<br/>

switch 문
------
switch 문을 사용하면 분기점 여러 개를 더욱 간결하게 표현할 수 있다. switch 문의 사용법은 다음과 같다.<br/>
```
switch(표현식) {
    case 표현식 1 : 실행문 1
    case 표현식 2 : 실행문 2
    ...
    case 표현식 n : 실행문 n
    default: 실행문 n + 1
}
```

반복문
======
반복문은 일정한 처리를 한 다음 원래 위치로 돌아가 똑같은 처리를 반복하는 처리를 표현한다.

while 문
------
while 문은 조건만 맞아떨어지면 일정한 처리를 계속 반복해서 실행한다. while 문의 사용법은 다음과 같다.<br/>
`while (조건식) 문장`<br/>
while 문 안에서는 break 문과 continue 문을 사용할 수 있다.<br/>
　• while 문 안에서 break를 실행하면 while 문에서 빠져나온다.<br/>
　• while 문 안에서 continue를 실행하면 while 문의 시작 부분으로 되돌아 간다.<br/>

do/while 문
------
do/while 문은 반복해서 실행할지를 마지막 부분에서 판단한다. do/while 문의 사용법은 다음과 같다.<br/>
`do 문장 while(조건식);`<br/>
do/while 문의 끝에는 반드시 세미클론이 붙는다. while 문과 마찬가지로 do/while 문 안에서는 break 문과 continue 문을 사용할 수 있다.

for 문
------
반복문은 대부분 세 가지 공통점이 있다. 바로 반복 조건의 초기화 작업, 반복문의 조건식, 반복 작업이 하나 끝났을 때 반복 조건을 갱싱하는 작업인다. for 문은 이 세 가지 작업을 명시적으로 한곳에 모아서 표기한다. for 문의 사용법은 다음고 같다.<br/>
`for( 초기화 식; 조건식; 반복식) 문장`<br/>
초기화 식을 입력하는 부분에 쉼포 연산자를 사용하면 표현식을 여러 개 작성할 수도 있다.
```javascript
for(var i = 1, sum = 0; i <= 10; i++){
    sum += i;
}
```
초기화 식, 조건식, 반복식은 모두 생략할 수 있다. 단, 소괄호 안에 있는 세미클론만큼은 생략할 수 었는데 이는 끝없이 반복하겠다는 뜻이 된다.
```javascript
for(;;){
    if( confirm("종료하시겠습니까?")) break;
}
```
for 문은 루프 카운터 변수인 i와 j의 값을 한꺼번에 바꾼다.
```javascript
for(var i=0; j=10; i<10; i++, j--) {...}
```

for/in 문
------
for/in 문은 객체 안의 프로퍼티를 순회하는 반복문이다. for/in 문의 사용법은 다음과 같다.<br/>
`for (변수 in 객체 표현식) 문장`<br/>
for/in 문이 실행되면 먼저 **객체 표현식**을 평가한다. 객체 표현식이 null 또는 undefined로 평가되면 for/in 문을 빠져나와 다음 작업으로 이동한다. 객체 표현식이 객체로 평가되면 객체의 프로퍼티 이름이 차례대로 **변수**에 할당되고 각각의 프로퍼티에 대해서 **문장**이 한 번씩 실행된다.
```javascript
var obj = {a:1, b:2, c:3};
for(var p in obj){
    console.log("p = " + p);
}
```
이 코드를 실행하면 다음처럼 출력된다.
```
p = a
p = b
p = c
```
for/in 문은 프로퍼티 이름만 꺼내 변수에 할당한다. 따라서 반복문 안에서 프로퍼티 값을 가져오려면 괄호 연산자를 사용해야 한다.
```javascript
var obj = {a:1, b:2, c:3};
for(var p in obj){
    console.log("obj." + p + " = " + obj.[p]);
}
```
이 코드를 실행하면 다음처럼 출력된다.
```
obj.a = 1
obj.b = 2
obj.c = 3
```
다른 반복문과 마찬가지로 반복문 안에서 문장을 여러 개 실행하려면 여러 문장을 블록으로 묶어서 블록 문장으로 만든다. 또한 for/in 문 안에서도 break 문과 continue 문을 사용할 수 있다.

점프문
======
점프문은 프로그램의 다른 위치로 이동하는 제어 구문이다. 자바스크립트에서 사용할 수 있는 점프문에는 break 문, continue 문, break 문, continue 문, return 문, throw 문이 있다.

라벨문
------
자바스크립트에서는 모든 문장에 라벨을 붙일 수 있으며 사용법은 다음과 같다.<br/>
`라벨 이름 : 문장`<br/>
**라벨 이름**에는 모든 식별자를 사용할 수 있다. 자바스크립트에서 라벨로 점프할 수 있는 문장은 break 문과 continue 문뿐이다.

break 문
------
break 문의 사용법은 다음과 같다.<br/>
`break;`<br/>
break 문에는 점프할 라벨을 지정할 수 있는데 사용법은 다음과 같다.<br/>
`break 라벨 이름;`<br/>
라벨을 지정한 break 문을 실행하면 라벨이 붙은 문장 끝으로 점프한다.

continue 문
------
continue 문의 사용법은 다음과 같다.<br/>
`continue;`<br/>
continue 문에는 점프할 라벨을 지정할 수 있는데 사용법은 다음과 같다.<br/>
`continue 라벨 이름;`<br/>
continue 문을 실행하면 반복문 실행을 멈추고 새로 시작한다. 이때의 동작은 반복문에 따라 달라진다.

|반복문|continue 문장이 반복을 새로 시작할 때의 동작|
|---|---|
|while 문|반복문의 처음으로 되돌아가서 조건식을 다시 평가한다. 그 결과가 true면 반복문을 처음부터 실행한다.|
|do/while 문|중간을 건너뛰고 반복문의 마지막 조건식을 평가한다. 그 결과가 true면 반복문을 처음부터 실행한다.|
|for 문|반복식을 실행한 후에 조건식을 평가한다. 그 결과사 true면 반복문을 이어서 실행한다.|
|for/in 문|반복문의 처음으로 되돌아간다. 지정한 변수에 할당되어 있는 프로퍼티의 다음 프로퍼티를 대상으로 작업을 시작한다.|
