# 1장

처음 만나는 자바스크립트
======
　자바스크립트가 어떤 언어이고, 어떤 목적으로 개발되었는지 알아본다.

자바스크립트는 어떤 언어인가?
------
　인터넷 웹 페이지는 다음과 같은 세 개의 언어로 만들어 진다.
* HTML(HyperText Markup Language): 텍스트, 이미지, 버튼, 메뉴 등과 같이 웹 페이지에 나타나는 모든 요소의 배치와 내용을 기술하는 언어
* CSS(Cascading Style Sheets): 색상이나 크기처럼 웹 페이지 요소의 스타일을 정할 때 사용하는 언어
* 자바스크립트: 사람의 근육처럼 웹 페이지에 동적인(움직임이 있는) 기능을 장착할 수 있게 도와주는 언어

자바스크립트는 어떻게 실행되나?
------
　자바스크립트는 '자바스크립트 엔진'이라는 프로그램이 해석해 실행한다. 자바스크립트 엔진은 기본적으로 웹 브라우저에 탑재되어 있다.

웹 에디터로 자바스크립트 편집하기
------
　코드샌드박스는 샌드박스(sandbox) 단위로 웹 언어를 입력하고 편집할 수 있는 웹 에디터이다. 이 에디터는 코드샌드박스 사이트에 접속하면 편리하게 코딩할 수 있는 환경을 제공한다.

변수와 상수
======

변수
------
　변수란 프로그램을 실행하는 과정에서 변경될 수 있는 값을 저장하는 저장소이다. 또한 변수는 어떤 값을 이름으로 가리킬 떄 사용하는 기능이기도 하다. 자바스크립트에서 변수는 다음과 같이 만든다.
```javascript
let age = 25;
```
　변수는 이름으로 구분하기 때문에 let으로 변수를 선언할 때는 이름을 중복해서 사용할 수 없다. 자바스크립트에서 키워드 var로도 변수를 선언할 수 있다.
```javascript
var age = 25;
```
　var를 이용한 변수 선언은 let과는 달리 이름을 중복해 선언해도 실핼할 수 있다. var를 사용하면 혼란을 야기하고 코드의 복잡도를 높이는 까닭에 가급적 변수 선언 키워드로는 let을 사용해야 한다.

상수
------
　상수 역시 변수처럼 이름을 가진 저장 공간이다. 그러나 상수는 변수와 달리 프로그램 실행 과정에서 변경할 수 없다.

자료형
======

자료형과 원시 자료형
------
　자료형(Type)이란 값을 성질에 따라 분류한 것이다. 자바스크립트는 자료형을 크게는 원시 또는 객체 자료형으로 나누고, 작게는 8개의 세부 자료형으로 나눈다. 원시 자료형은 원시 타입 또는 기본 타입이라고 한다. 원시 자료형은 한 번에 단 하나의 값만 가질 수 있는 타입이다. 객체 자료형은 객체, 배열, 함수이다.<br/>

**숫자형**<br/>
　자바스크립트에서 숫자형(Number Type)은 수의 종류를 구분하지 않는다. 즉, 소수, 음수, 실수와 같은 수를 모두 포함한다.
```javascript
let age = 25;
let tall = 175.9;
let minus = -20;
```
　숫자형에는 정수, 실수 말고도 일반적이지 않은 몇 가지 값이 있다.
```javascript
let inf = Infinity;
let minf = -Infinity;
let nan = NaN;
```
　Infinity는 양의 무한대, -Infinity는 음의 무한대를 의미하는 값이다. 이 값은 최솟값이나 최댓값을 구할 때 주로 사용한다. 또한 Infinity는 0으로 어떤 수를 나눈 결과이기도 하다. 자바나 C 언어에서는 0으로 어떤 수를 나누면 오류가 발생하지만, 자바스크립트는 Infinity라는 결과를 얻게 된다. **NaN**은 Not a Number라는 뜻으로 표현이 불가능한 숫자형의 결과를 표현할 때 사용하는 값이다. 예를들어, 숫자와 문자열을 곱하면 정상적인 연산의 결과물이 나올 수 없으므로 NaN이라는 값을 얻는다.<br/>

**문자형**<br/>
　문자형(String Type)은 가람의 이름과 같은 문자열을 포함하는 자료형이다.
```javascript
let myName = "이정환";
```
　문자형에 덧셈 연산자를 사용하면 두 개의 문자를 이어 붙이고 벡터(``)를 이용해도 문자형을 만들 수 있다.
```javascript
let name = "이정환";
let welcomeText = '님 반가워요!'; // 작은따옴표를 이용
let resultWelcomeText = name + welcomeText;

console.log(resultWelcomeText); // 이정환님 반가워요!

let guestName = `이정환`;       // 벡터 사용
``` 
　벡터를 이용하면 문자형 사이에 변수를 사용할 수 있어, 값이 변하는 동적인 문자열을 생성할 때 유용하다. 벡터를 이용한 문자열을 "템플릿 리터럴(Template Literal)"이라고도 한다.
```javascript
let name = "이정환";
let location = "역곡";
let introduce = `${name}은 ${location}에 살고 있습니다.`;

console.log(introduce); // 이정환은 역곡에 살고 있습니다.
```

**불리언, null, undefined**<br/>
　불리언 형(Boolean Type)은 참(true) 또는 거짓(false)만을 저장하는 자료형이다. null은 "아무것도 없다"라는 뜻으로, 변수에 아무런 값도 할당할 필요가 없을 때 사용한다. undefined는 "미정의 값"이라는 뜻이다. 정상정익 할당이 이루어지지 않았을 때 자동으로 할당되는 undefined는 자바스크립트 프로그래밍에서 상당히 많은 오류를 일으킨다.

형 변환
======
　형 변환에는 프로그래머가 의도적으로 자료형을 변환하는 '명시적 형 변환'과 자바스크립트 엔진이 알아서 변환하는 '묵시적 형 변환'이 있다.

묵시적 형 변환
------
　묵시적 형 변환은 자바스크립트 엔진이 스스로 알아서 변환하는 작업이다.
```javascript
let number = 10;
let string = "20";

const result = number + string; 
console.log(result);  // 1020
```
　위는 자바스크립트가 암묵적으로 숫자를 문자로 형 변환해 계산했기 때문이다.

명시적 형 변환
------
　명시적 형 변환은 묵시적 형 변환과 반대로 내장 함수 등을 이용해 프로그래머가 의도적으로 어떤 자료형을 다른 자료형으로 변경하는 작업이다.<br/>

**숫자형으로 변환**<br/>
```javascript
let strA = "10";
let strB = "10개";

let numA = Number(strA);
let numB = Number(strB);

console.log(numA);  // 10
console.log(numB);  // NaN
```
　함수 Number는 자바스크립트가 기본적으로 제공하는 내장 함수로, 제공된 문자열을 숫자로 변환해 반환한다. 그러나 변수 strB처럼 숫자가 아닌 문자를 포함한 문자열은 정상적으로 변환되지 않기 때문에 NaN을 반환한다.<br/>
　만약 숫자뿐만 아니라 문자열도 함께 포함된 문자열을 숫자로 변환하고 싶다면, 함수 parseInt를 사용한다.
```javascript
let strA = "10";
let strB = "10개";

let numA = parseInt(strA, 10);
let numB = parseInt(strB, 10);

console.log(numA);  // 10
console.log(numB);  // 10
```
　함수 parseInt는 Number처럼 괄호 안에 있는 문자열을 숫자로 변환하는 자바스크립트의 내장 함수 이다. Number과 달리 괄호 안에 두 개의 값을 콤마로 구분해 전달하는데, 첫 번째 값은 변환하려는 문자열이고, 두 번째 값은 진수이다. 만약 문자열의 첫문자부터 숫자가 아닌 문자로 시작한다면 함수 parseInt는 NaN을 반환한다.<br/>

**문자열로 변환**<br/>
```javascript
let num = 2022;
let str = String(num);

console.log(str); // 2022
```
　String은 자바스크립트 내장 함수로 인수로 제공한 값을 문자열로 변환해 반환한다.
```javascript
let varA;
let varB = null;
let varC = true;

let strA = String(varA);
let strB = String(varB);
let strC = String(varC);

console.log(strA);  // undefined
console.log(strB);  // null
console.log(strC);  // true
```
　undefined값은 문자열 undefined, null 값은 문자열 null, true 값은 문자열 true로 변환된다.<br/>

**불리언으로 변환**<br/>
　불리언 값으로 변환하는 내장 함수는 Boolean이 있다.
```javascript
let varA = "하이";
let varB = 0;
let varC = "";

let boolA = Boolean(varA);
let boolB = Boolean(varB);
let boolC = Boolean(varC);

console.log(boolA); // true
console.log(boolB); // false
console.log(boolC); // false
```

연산자
======

대입 연산자
------
　대입 연산자(=)는 가장 기본이 되는 연산자로서 변수에 값을 할당하는 역할을 한다.

산술 연산자
------
　산술 연산자는 덧셈(+), 뺄샘(-), 곱샘(*), 나눗셈(/), 나머지 연산(%)처럼 프로그래밍에 필요한 가장 기본적인 계산 기능을 수행하는 연산자이다.

복합 대입 연산자
------
　복합 대입 연산자는 대입 연산자와 산술 연산자의 기능을 함께 이용할 때 사용한다. 복합 대입 연산자는 산술 연산자와 대입 연산자를 서로 이어 붙여 사용한다.

증감 연산자
------
　증감 연산자는 값을 1씩 늘리거나 줄일 때 사용하는 연산자이다. 이 증감 연산자는 덧셈 또는 뺄셈 연산자를 두 개 연달아 붙여 사용한다.

논리 연산자
------
　논리 연산자는 참(true)과 거짓(false)을 포함하는 불리언 값을 다룰 때 사용하는 연산자이다. 논리연산자에는 3종류가 있다.

|논리 연산자|설명|
|---|---|
|OR(\|\|)|둘 중 하나라도 참이면 참|
|AND(&&)|둘 중 하나라도 거짓이면 거짓|
|NOT(!)|참이면 거짓, 거짓이면 참|

비교 연산자
------
　비교 연산자는 말뜻 그대로 두 값을 비교하는 연산자이다.

|비교 연산자|설명|
|---|---|
|===|같다(== 연산자는 값만 비교할 뿐 자료형은 비교하지 않음)|
|!==|같지 않다(값과 자료형 중 하나라도 다르면 참, != 연산자는 자료형을 비교하지 않음)|
|>|크다|
|>=|크거나 같다|
|<|작다|
|<=|작거나 같다|

null 병합 연산자
------
　null 병합 연산자(Nullish Coalescing Operator)는 값이 확정된 변수를 찾을 때 사용하는 연산자이다. 자바스크립트에서는 값이'없음'을 나타내는 자료형으로 null과 indefined가 있다. null이나 undefined가 있는 변수를 값이 확정되지 않은 변수라고 한다. null 병합 연산자 ??를 사용하면, 값이 확정된 변수를 쉽게 찾아 낼 수 있다.
```javascript
let varA = 10;
let varB = 20;
let varC;

console.log(varA ?? varB);  // 10, null 병합 연산자에서는 ?? 연산자 기준 왼쪽의 값을 연산 결과로 반환
console.log(varC ?? varB);  // 20, null 병합 연산자는 값이 확정된 변수인 varB의 값을 연산 결과로 반환
```
　실무에서 null 병합 연산자를 이용하면 다음과 같은 상황을 간단하게 해결할 수 있다.
```javascript
let name;
let nickname = "Winterload";

let user = name ?? nickname;

console.log(user);  // Winterload
```

동적 타이핑과 typeof 연산자
------
　자바스크립트는 변수에 숫자를 저장했다가 문자로 바꿔도 오류가 발생하지 않는다. 자바스크립트 변수는 값을 저장할 때마다 자료형이 동적으로 결정되기 때문이다. 저장하는 변숫값에 따라 변수의 자료형도 함께 변경되는 특징을 '동적 타이핑(Dynamic Typing)'이라고 한다.<br/>
　자바스크립트 자료형의 이러한 유연함은 때로는 단점이 되기도 한다. 프로그래머가 변수의 자료형이 변경되었다는 사실을 모르고 코드를 작성하면 프로그램이 의도하지 않게 동작하거나 오류가 발생할 수 있다. 이런 상황을 대비해 typeof 연산자를 이요해 변수의 자료형을 확인할 수 있다.
```javascript
let varA = 1;
varA = '이정환';

console.log(typeof varA); // string
```

삼항 조건 연산자
------
　삼항 조건 연산자(삼항 연산자)는 유일하게 자바스크립트에서 3개의 피연산자를 취하는 연산자이다. 삼항 연산자는 다음과 같이 ? 앞에 조건식을 작성하고 클론(:)을 기준으로 앞은 조건식이 참일 때 그리고 뒤는 조건식이 거짓일 때 수행할 명령을 작성하면 된다.
```
조건식 ? 참일 때 명령 수행 : 거짓일 때 명령 수행
```

조건문
======
　조건문이란 특정 조건을 만족할 때 원하는 동작을 수행하게 하는 프로그래밍의 기본 문법중 하나이다. 자바스크립트의 조건문에는 if문과 switch/case 문이 있다.

if 문
------
　if 문은 if 키워드 다음의 소괄호(())애 조건식을 입력하고, 중괄호({})에서는 해당 조건식이 참일 때 수행할 명령을 입력한다. if 문에서 else를 사용하여 거짓일 때 수행할 명령을 추가할 수 있다. else if문은 두 개 이상의 조건이 있는 경우 사용하는 조건문이다.

switch 문
------
　switch 문은 중첩 if 문처럼 비교할 조건이 많을 때 사용하는 조건문이다. switch 문은 식이나 값을 case 문과 비교해 정확히 일치할 때만 수행한다. switch 문에서는 break 문을 사용하는데 case 문에서 수행할 명령을 작성하고, break를 입력해 "실행할 명령이 끝났다."라고 알려주어야 한다. break 문을 작성하지 않아도 오류가 발생하지는 않는다. 그거나 break를 입력하지 않으면, 조건식과 일치해 실행한 case 문 이후의 명령까지 모두 차례로 수행한다.

반복문
======
　프로그래밍에서 동일하거나 유사한 동작이 반복해서 나올 때는 반복문(Loop)을 사용한다.

반복문의 유용성과 for문
------
　자바스크립트의 반복문에는 for 문, while 문, do while 문 등이 있다.

반복문 강제 종료하기, 건너뛰기
------
　break 문을 사용하면 조건식에서 정의한 반복문의 종료 조건과 상관없이 반복을 강제로 종료할 수 있다. continue 문은 break 문과 유사하게 동작하지만, 반복을 멈추는 대신 다음 반복 과정으로 건너뛴다.

함수
======
　자바스크립트에서는 공통으로 사용하는 유사 코드를 하나로 묶어 '함수'라는 이름으로 사용할 수 있다.

함수가 필요한 이유
------
　함수를 사용하면 유사하게 동작하는 중복 코드를 하나의 블록 단위로 묶을 수 있다. 그리고 이 블록에 이름을 붙여 원할 때마다 호출해 사용할 수 있다.

함수 선언
------
　자바스크립트에서는 기본적으로 다음과 같이 함수를 만든다.
```
function 함수 이름 (매개변수) {
  함수가 수행하는 명령
}
```

함수 호출
------
　함수는 이름을 불러 주어야 실행되는데, 이를 '함수 호출'이라고 한다.

함수의 인수와 매개변수
------
　자바스크립트에서는 '인수'와 '매개변수'라는 기능을 이용해 함수를 호출하면서 값을 주고받는다. 인수는 함수를 호출하면서 넘겨주는 값이고, 매개변수는 함수에서 넘겨받은 인수를 저장하는 변수이다.

함수 반환
------
　자바스크립트의 함수에서 값을 반환하려면 return 문을 사용한다.

중첩 함수
------
　자바스크립트는 함수 내에서 또 다른 함수를 선언할 수 있다. 특정 함수 내부에서 선언된 함수를 '중첩 함수(Nested Function)'라고 한다. 중첩 함수를 많이 두면 가독성을 헤치는 단점이 있으나, 적절히 활용하면 함수 내에서 서로 역할을 분담할 수 있어 중복 코드를 방지하는 데 도움이 된다.

함수의 호이스팅
------
　호이스팅(Hoisting)이란 프로그램에서 변수나 함수를 호출하거나 접근하는 코드가 함수 선언보다 위에 있음에도 불구하고, 마치 선언 코드가 위에 있응 것처럼 동작하는 자바스크립트만의 독튿한 기능이다.<br/>
　자바스크립트에서 함수는 선언하기 전에도 호출할 수 있는데, 이런 기능을 '호이스팅'이라고 한다. 이런 현상이 일어나는 이유는 자바스크립트의 내부 알고리즘때문이다. 자바스크립트는 코드를 실행하기 전에 준비 단계을 거친다. 준비 단계에서 중첩 함수가 아닌 함수들은 모두 찾아 미리 생성해 둔다. 자바스크립트 코드는 이런 준비 단계를 거친 다음에 실행된다. 따라서 함수 선언 코드를 호출보다 늦게 작성해도 자연스럽게 호출할 수 있다.

함수 표현식
------
　자바스크립트는 함수 선언 말고도 함수를 만드는 또 다른 방법이 있다. 바로 '함수 표현식'을 이용하는 방법이다. 함수 표현식이란 함수를 생성하고 변수에 값으로 저장하는 방법이다.
```javascript
let greeting = function() {
  console.log("hello");
};

greeting(); // hello
```
　자바스크립트에서는 함수를 숫자나 문자열처럼 값으로 취급한다. 그래서 변수에 함수를 저장할 수 있다. 변수에 함수를 저장하면 변수 이름으로 호출할 수 있다. 이렇게 함수를 변수의 값으로 저장해 생성하는 방법을 함수 표현식이라고 한다.<br/>
　위 코드에서 함수를 만들 때 이름을 생략했다. 이런 함수를 '익명 함수'라고 한다.<br/>
　함수 표현식으로 만든 함수는 함수 선언으로 만든 함수와는 달리 호이스팅되지 않는다.

콜백 함수
------
　함수는 다른 함수의 인수(= 값)로도 전달할 수 있는데, 이를 '콜백 함수(Callback Function)'라고 한다.

화살표 함수
------
　화살표 함수는 익명 함수를 매우 간결하게 작성할 때 사용하는 함수 표현식의 단축 문법이다. 화살표 함수는 다음과 같은 형식으로 사용한다.
```
let funcA = (매개변수) => 반환값;
```
　화살표 함수 funcA는 다음 함수와 동일하다.
```
let funcA = function() {
  return 반환값;
};
```

스코프
======
　자바스크립트의 변수와 함수는 생성과 동시게 접근하거나 호출할 때 일정한 제약을 갖는데, 이를 스코프(Scope)라고 한다. 스코프는 변수나 함수의 제약 범위를 뜻한다.

전역, 지역 스코프
------
　변수가 전역 스코프를 갖는다는 것은 해당 변수를 코드 어디에서나 접근할 수 있다는 의미이다. 반면 변수가 지역 스코프르 갖는다는 것은 특정 영역에서만 해당 변수에 접근할 수 있다는 의미이다.

블록, 함수 스코프
------
　자바스크립트의 변수나 함수는 중괄호로 둘러싸인 부분을 뜻하는 '블록(Block)'을 기준으로 지역 스코프가 결정된다. 블록 기준으로 지역 스코프를 정한다고 해서 '불록 스코프'리고한다. 대다수의 언어는 변수를 선언한 블록에 따라 지역 스코프가 정해진다.<br/>
　그러나 자바스크립트의 지역 스코프는 블록 스코프 외에도 한가지 더 있다. 바로 함수를 기준으로 지역 스코프를 정하는 '함수 스코프'이다.

객체
======
　객체는 숫자형이나 문자형과 같은 원시 자료형과 달리 다양한 값을 담는 자료형이다.

객체 생성과 프로퍼티
------
　자바스크립트에서는 2가지 방법으로 객체를 생성할 수 있는데, 다음과 같이 '리터럴' 또는 '생성자' 문법을 사용한다.
```
let objA = {};            // '객체 리터럴' 문법
let onjB = new Object();  // '객체 생성자' 문법
```

객체 프로퍼티 다루기
------
　객체는 key와 value로 이루어진 프로퍼티의 모음이다. 객체에서 프로퍼티를 찾고, 추가하고, 삭제하는 등의 모든 연산은 key를 이용해 수행한다.
　key를 이용하면 객체의 프로퍼티에 접근할 수 있다.
```javascript
let person = {
  name: "이정환",
  age: 25,
  "like cat": true
};

const personName = person.name;
const personAge = person["age"];

console.log(personName);  // 이정환
console.log(personAge);   // 25
```
　새로운 프로퍼티를 추가하는 방법은 다음과 같이 점 표기법과 괄호 표기법을 이용해 새로운 프로퍼티를 추가할 수 있다.
```javascript
let person = {
  name: "이정환",
  age: 25,
  "like cat":true
};

person.gender = "male";
person["nickname"] = "Winterlood";

console.log(person.gender);       // male
console.log(person["nickname"]);  // Winterlood
```

　다음은 객체의 프로퍼티를 수정하는 예이다.
```javascript
let cat = {
  name: "치삼이",
  age: 4
};

cat.name = "치삼";
cat["age"] = 5;

console.log(cat); // {name: "치삼", age: 5}
```
　다음은 프로퍼티를 삭제하는 예이다.
```javascript
let cat = {
  name: "치삼이",
  age: 4
};

delete cat.name;
delete cat["age"];

console.log(cat); // {}
```

배열
======
　배열은 순서가 있는 요소의 집합이자 여러 개의 항목을 담는 리스트이다.

배열 선언
------
　자바스크립트에서는 두 가지 방법으로 빈 배열을 생성한다.
```javascript
let arrA = new Array(); // 배열 생성자
let arrB = [];          // 배열 리터럴
```

배열 인덱스
------
　배열과 객체 둘 다 여러 데이터를 저장할 수 있고, 저장할 데이터릐 자료형에도 아무런 제약이 없다. 배열과 객체의 차이점은 객체는 key가 있지만 배열은 그렇지 않다는 점이다.<br/>
　객체에서는 특정 데이터에 접근할 때 key를 이용하지만, 배열은 데이터의 위치를 key처럼 사용할 수 있는 인덱스가 있다. 배열에서 특정 데이터에 접근하려면 데이터의 위치를 나타내는 인덱스를 객체의 괄호 표기법처럼 사용하면 된다.
```javascript
let food = ["짜장면", "피자", "치킨"];

console.log(food[0]); // 짜장면
console.log(food[1]); // 피자
console.log(food[2]); // 치킨
```
　인덱스란 배열 요소의 위치를 0부터 시작하는 숫자로 순서대로 표현한 것이다. 배열은 인덱스 기능을 이용해 배열 food의 요소를 짜장면 0, 피자 1, 치킨 2와 같이 순서대로 번호를 매긴다.


# 2장
truthy&falsy
======
　자바스크립트는 불리언 자료형의 참(true)이나 거짓(false)이 아닌 값도 상황에 따라 참, 거짓으로 평가하는 특징이 있다. 이런 특징을 'truthy & falsy'라고 한다.

truthy&falsy한 값
------
　자바스크립트에서 어떤 값을 '거짓'으로 판별하고(falsy), 참으로 평가하는지(truthy) 살펴본다.<br/>
　falsy한 값이란 불리언 자료형의 거짓(false)은 아니지만 거짓과 같은 의미로 쓰이며, 조건식에서 거짓(false)으로 평가한다. falsy한 값으로는 undefined, null, 0, -0, NaN, "", 0n, 7가지가 있다.<br/>
　truthy한 값은 불리언 자료형의 참(true)은 아니지만 참과 같은 의미로 쓰이며, 조건식에서 참(true)으로 평가한다. falsy한 값을 제외하면 모든 값은 truthy한 값이다.

truthy&falsy 응용하기
------
　truthy 또는 falsy한 값은 조건식을 간결하게 만든다.<br/>
　'값이 비었다'는 의미는 특정 변수의 값이 undefinde나 null일 때 쓰이는 표현이다. undefined나 null 값 모두 falsy하기 때문에 조건문에서 특정 변수에 값이 있는지 없는지 확인할 때 사용한다.
```javascript
let varA;

if (varA) {
  console.log("값이 있음");
} else {
  console.log("값이 없음"); // 값이 없음
}
```
　변수 varA는 선언만 하고 값을 할당하지 않았으므로 undefined 값이다. 빈 문자열을 제외한 모든 문자열은 truthy한 값이다. 조건문에서 문자열이 공백인지 아닌지 확인하는 용도로 자주 사용한다.
```javascript
const str = "";

if(str) {
  console.log("공백 아님");
} else {
  console.log("공백임");  // 공백임
}
```

단락 평가
======
　true||false와 같은 비교식은 첫 번째 피연산자의 값이 true이므로 두 번째 피연산자의 값이 무엇이든 연산 결과는 true이다. 또한 false && true와 같은 식은 첫 번째 피연산자의 값이 false이므로 두 번째 피연산자가 무엇이든 연산 결과는 false이다.<br/>
　이렇듯 논리 연산에서 첫 번째 피연산자의 값만으로 해당 식의 결과가 확실할 때, 두 번째 값은 평가하지 않는 것을 '단락 평가(Short-Circuit Evaluation)'라고 한다. 단락 평가에는 AND와 OR 논리 연산자의 특징을 이용하는 두 가지 방식이 있다.

AND 단락 평가
------
　AND를 의미하는 && 연산자는 피연산자의 값이 하나라도 거짓이면 거짓을 반환한다. 따라서 왼쪽에 위치한 첫 번째 피연산자 값이 false면, 단락 평가가 이루어지므로 두 번째 피연산자는 계산하지 않는다.

OR 단락 평가
------
　OR 연산을 의미하는 || 연산자는 피연산지의 값이 하나라도 참이면 참을 반환한다. 따라서 왼쪽에 위치한 첫 번째 피연산자의 값이 true면, 단락 평가가 이루어져 두 번째 피연산자 값은 계산하지 않는다.

객체 자료형 자세히 살펴보기
======

배열과 함수가 객체인 이유
------
　자바스크립트의 원시 자료형을 제외한 모든 자료형은 객체 자료형이다. 따라서 논리적으로 배열과 함수 역시 객체 자료형이다.<br/>
　배열은 인덱스로 연속적인 값을 저장하는 데 특화된 자료형이다. 자바스크립트의 배열은 객체 자료형에 몇 가지 기능을 추가헤 다른 언어의 배열처럼 동작하는 특수한 객체라고 할 수 있다.<br/>
　자바스크립트의 함수 또한 객체이다. 그리고 함수는 값으로 취급된다. 이러한 특징 떄문에 함수를 값으로 저장하는 함수 표현식이 가능하고, 다른 함수에 인수로 전달할 수 있다.

객체와 참조
------
　객체 자료형은 값의 크기가 유동적으로 변하기 때문에 자바스크립트는 참조(Reference)라는 기능을 이용한다. 참조란 실제로 값을 저장하는 것이 아니라 값을 저장한 곳의 주소만 저장하는 방식이다.<br/>

**원시 자료형과 객체 자료형의 저장 방식 비교**<br/>
　원시 자료형은 값을 변수에 저장할 때 값 그래로 저장한다. 반면 객체 자료형 즉, 참조 자료형은 값의 주솟값을 저장한다.<br/>

**참조에 의한 비교**<br/>
　객체를 비교할 때는 값이 아닌 참조값으로 비교한다. 이를 '참조에 의한 비교'라고 한다.

반복문 응용하기
======

배열과 반복문
------
　배열은 순서대로 데이터를 저장하는 특징이 있다. 배열과 반복문을 결합해 사용하는 방법에는 여러 형태가 있다.<br/>

**인덱스를 이용한 순회**<br/>
　배열에는 데이터의 저장 순서를 의미하는 인덱스가 있다. 인덱스를 0부터 1씩 증가하며 차례대로 데이터에 접근하면 배열의 모든 요소에 접근할 수 있다.<br/>

**for...of 문을 이용한 순회**<br/>
　for 문의 특수한 형태인 for...of 문은 배열을 더 간결하게 순회한다. for...of 문은 for 문과 달리 of 뒤의 배열에서 요소를 하나씩 순서대로 꺼내 변수에 저장한다.

객체와 반복문
------
　반복문을 이용해 객체에 저장된 프로퍼티를 순회하는 방법을 알아보자.<br/>

**Object.keys를 이용한 순회**<br/>
　객체 메서드인 Object.keys는 객체 프로퍼티의 key를 배열로 반환한다.<br/>

**Object.values를 이용한 value 순회**<br/>
　프로퍼티의 value만 배열로 반환하는 Object.value 메서드가 있다.<br/>

**for...in 문을 이용한 순회**<br/>
　배열을 순회할 때의 for...of 문처럼, 객체를 순환할 때는 for...in 문을 사용한다. for...in 문으로 객체를 순회하면, for 문과 Object.keys 메거드보다 더 간결한 코드를 작성할 수 있다.

구조 분해 할당
======
　구조 분해 할당(Destructuring Assignment)은 말뜻 그대로 구조를 분해해 할당하는 문법이다. 배열이나 객체에서 요소를 해체해 개별 변수에 그 값을 담을 때 사용한다.

* 배열의 구조 분해 할당
* 객체의 구조 분해 할달
* 함수의 매개변수가 객체일 때 구조 분해 할당하기

스프레드 연산자와 rest 매개변수
======

스프레드 연산자
------
　스프레드(Spread) 연산자는 '...'기호로 표기하는데, 전개 연산자라고도 부른다. 스프레드 연산자를 이용하면 배열, 문자열, 객체 등과 같이 반복이 가능한 객체의 값을 개별 요소로 분리할 수 있다.

rest 매개변수
------
　rest 매개변수는 나머지 매개변수라고 하며, 스프레드 연산자처럼 기호 '...'으로 표기한다. 스프레드 연산자는 배열이나 객체처럼 반복 가능한 값을 개별 요소로 분리하지만, rest 매개변수는 반대로 개별 요소를 배열로 묶는다.

배열과 메서드
======
　자바스크립트는 배열을 쉽게 다룰 수 있도록 여러 매서드를 제공한다. 이런 메서드를 '배열 메서드'라고 한다.

Date 객체와 날짜
======
　자바스크립트에는 시간을 표현하는 Date 객체가 있다. Date는 배열이나 함수처럼 특수한 목적을 수행하기 위해 기능이 추가된 객체이다. Date 객체는 날짜와 시간을 저장하며 이와 관련한 유용한 메서드도 함께 제공한다.<br/>
　Date 객체를 활용하면 특정 게시물의 생성 시간을 저장하거나 오늘의 날짜를 출력하거나 타이머를 만드는 등 시간과 관련된 기능을 쉽게 구현할 수 있다.

비동기 처리
======
　비동기 처리를 이용하면 오래 걸리는 작업이 종료될 때까지 기다리지 않고 다음 작업을 수행하는 등 유연한 프로그래밍이 가능하다.

동기와 비동기
------
　순차적으로 코드를 실행하는 것을 동기(Synchronous)라고 한다. 동기는 앞의 작업을 완료해야 다음 작업을 실행할 수 있다. 자바스크립트는 기본적으로 동기적으로 동작한다.<br/>
　특정 작업을 다른 작업과 관계없이 독립적으로 동작하게 만드는 것을 비동기(Asynchronous)라고 한다.

콜백 함수로 비동기 처리하기
------
　콜백 함수를 이용하면 비동기 작업의 결괏값을 사용할 수 있다.

프로미스 객체를 이용해 비동기 처리하기
------
　프로미스(Promise)는 비동기 처리를 목적으로 제공되는 자바스크립트 내장 객체이다. 프로미스는 Date 객체처럼 특수한 목적을 위해 다양한 기능을 추가한 객체이다. 프로미스를 이용하면 콜백 함수를 이용한 비동기 처리보다 더 쉽게 비동기 작업을 수행할 수 있다.<br/>
　프로미스는 비동기 작업을 진행 단계에 따라 3가지 상태로 나누어 관리한다.
* 대기(Pending) 상태: 작업을 아직 완료하지 않음
* 성공(Fulfilled) 상태: 작업을 성공적으로 완료함
* 실패(Rejected) 상태: 작업이 모종의 이유로 실패함

　프로미스 객체는 다음과 같이 만든다.
```javascript
const promise = new Promise(실행함수);
```
　프로미스 객체를 만들 때 인수로 실행 함수(Executor)를 전달한다. 실행 함수란 비동기 작업을 수행하는 함수이다. 이 함수는 프로미스 객체를 생성함과 동시에 실행되면 2개의 매개변수를 제공받는다.<br/>
　실행 함수가 제공받는 2개의 매개변수는 다음과 같다.
* resolve: 비동기 작업의 상태를 성공으로 바꾸는 함수
* reject: 비동기 작업의 상태를 실패로 바꾸는 함수


# 3장
Node.js란?
======
　Node.js는 하나의 자바스크립트 런타임이다. Node.js 등장 이전에는 웹 브라우저가 유일한 자바스크립트 런타임이었다. Node.js 등장 이후 어떤 환경에서도 자바스크립트를 실행할 수 있게 되었다. Node.js는 vscode의 터미널에서 사용할 수 있다.

Node.js 패키지
======
　복잡한 프로그램을 만들기 위해서는 여러 개의 자바스크립트 파일이 필요하다. 하나의 프로젝트에서 여러 개의 자바스크립트 파일을 Node.js를 이용해 실행할 때는 패키지(package) 형태로 구성한다. 패키지는 Node.js에서 여러 개의 자바스크립트 파일을 실행하고 관리하는 일종이 관리 단위이다.

패키지 만들기
------
　패키지는 여러 파일을 마치 하나의 파일처럼 다룰 수 있게 해주는 관리 단위이다. 그런데 패키지 단위로 여러 파일을 관리하려면 최상위 폴더인 '루트 폴더'가 필요하다.<br/>
　패키지를 생성하려면 npm을 이용해야 한다. npm은 Node Package Manager의 약자로, Node.js 패키지를 관리하는 도구이다. npm에서는 패키지를 관리하기 위한 유요하고 간편한 명령어와 기능들을 제공한다.<br/>
　비주얼 스튜디오 터미널에서 다음 명령어를 입력한다.
```
npm init
```
　npm init은 Node.js 패키지를 초기화 하는 명령어이다. 초기화란 Node.js 패키지를 구성하는 데 필요한 최소한의 구성 요소를 자동으로 생성하는 과정이다.<br/>
<p align="center"><img src="/Week5/img/3-1.png" width="400"></p>

　초기화된 패키지의 package.json에는 기본적으로 다음 항목들이 존재한다.
* name: 패키지 이름
* version: 패키지 버전
* description: 패키지 설명
* main: 패키지의 소스 코드 파일 중 메인 역할을 담당하는 소스 코드 파일
* scripts: 패키지를 쉽게 다루기 위해 지정한 매크로 명령어
* author: 패키지를 만든 사람
* license: 패키지의 라이선스

패키지 스크립트 사용하기
------
　Node.js 패키지의 package.json에는 script라는 항목이 있다. 이 script 항목은 복잡한 명령어를 간단한 명령어로 변경하는 일종의 매크로 기능을 지원한다. scripts 항목을 직접 수정하고 사용해본다.<br/>
　먼저 index.js라는 파일을 생성하고 다음과 같이 코드를 작성한다.
```javascript
console.log("index run");
```
　index.js를 실행하기 위해서는 node 명령어와 함께 경로를 명시해야 한다. 그러나 package.json의 scripts 항목을 이용하면 아주 간단하게 index.js를 실행할 수 있다. package.json의 scripts 항목을 다음과 같이 수정한다.
```json
{
  (...)
  "scripts": {
    "start": "node index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  (...)
}
```
　터미널에 `npm run start`를 입력하면 package.json에 기록한 scripts에서 일치하는 명령어를 찾아 실행한다.
<p align="center"><img src="/Week5/img/3-2.png" width="400"></p>

Node.js 모듈 시스템
======
　여러 파일로 이루어진 패키지에서 각각의 파일이 다른 파일을 불러와 사용하는 모듈 시스템이 대해 알아본다.

모듈과 모듈 시스템
------
　모듈이란 독립적으로 존재하는 프로그램의 일부로 재사용이 가능한 것들로, 다른 프로그램의 부품으로 사용할 수 있다.<br/>
　자바스크립트에서는 독립된 하나의 파일을 '모듈'이라고 부른다. 자바스크립트 모듈은 대개 특정 정보를 담은 하나의 객체거나 특정 목적을 지닌 복수의 함수로 구성하는 경우가 많다.<br/>
　모듈을 사용하는 방법을 '모듈 시스템'이라고 한다. 자바스크립트에는 다양한 모듈 시스템이 있다. ES 모듈 시스템을 중심으로 살펴보자.

ES 모듈 시스템
------
　ES 모듈 시스템은 ECMAScript 모듈 시스템의 약자로, 줄여서 ESM이라고 한다.<br/>

**ESM 사용 설정하기**<br/>
　Node.js는 기본적으로 ESM이 아닌 CJS 모듈 시스템을 사용한다. 따라서 ESM 모듈 시스템을 사용하려면, package.json에서 설정을 변경해야 한다.
```json
{
  "name": "chapter3",
  "version": "1.0.0",
  "description": "",
  "main": "sample.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "type": "module"
}
```

**개별 내보내기**<br/>
　자바스크립트에서 모듈은 단지 하나의 파일일 뿐이다. 그래서 모듈의 정의처럼 '독립적이고 재사용이 가능'한 자바스크립트 파일은 다른 파일에서 불러와 사용할 수 있다.<br/>
　모듈이 필요한 이유는 특정 파일의 값이나 함수를 다른 파일에서 공유하기 위함이다. 그런데 특정 값이나 함수를 다른 파일에서 공유하려면, 먼저 해당 파일에서 내보내(export)는 공유 설정 작업이 선행되어야 한다.<br/>

**개별 불러오기**<br/>
　ESM은 import문으로 모듈에서 값을 불러온다.<br/>

**전부 불러오기**<br/>
　ESM에서는 불러올 값이 많다면, import * as A from B 형식으로 모듈이 내보낸 값을 한 번에 불러올 수 있다.<br/>

**기본값으로 내보내기**<br/>
　ESM에서는 export 키워드 다음에 default를 붙여 모듈의 기본값으로 내보낼 수 있다.<br/>

라이브러리 사용하기
======
　Node.js 패키지에서는 외부 패키지를 설피해 사용할 수 있다. 외부 패키지란 자신이 만든 Node.js 패키지를 서버에 올려 다른 사람도 사용할 수 있도록 배포한 파일이다.<br/>
　외부 패키지를 다른 말로 라이브러리라고 한다. 라이브러리는 프로그램을 개발할 때 공통으로 사용할 수 있는 기능들을 모아 모듈화한 것이다. 라이브러리는 완전한 프로그램이 아니며 특정 기능만을 수행한다.


# 4장
리액트의 특징
======
　리액트의 탄생 배경과 그 특징에 대해 들여다 본다.

컴포넌트 기반의 유연성
------
　리액트는 유연성이 있기 때문에 새로운 기능을 추가하거나 기능을 업그레이드할 때 코드를 많이 수정하지 않아도 된다.

중복 코드와 유연하지 못한 구조
------
　동일한 내용을 여러 번 작성해야 하는 코드를 흔히 중복코드라고 한다. 코드의 중복은 유연성을 크게 해친다.

컴포넌트 기반의 유연한 구조
------
　리액트는 모듈화를 이용해 중복 코드를 제거한다. 즉, 여러 페이지에서 공통으로 사용하는 코드를 '컴포넌트'단위의 모듈로 만들어 놓고 필요할 때 호출해 사용한다. 컴포넌트는 리액트를 대표하는 중요 개념 중 하나인데, 이 개념에는 '페이지를 구성하는 요소'라는 의미가 포함되어 있다.<br/>
　리액트의 컴포넌트는 어떤 페이지에서도 불러올 수 있다. 예를 들어 A 페이지에서 헤더 컴포넌트가 필요하면 해당 페이지로 불러오면 되고, B 페이지에서 필요하면 똑같은 방식으로 불러와 사용하면 된다. 필요가 없어지면 삭제하면 그만이다. 이렇듯 리액트에서는 컴포넌트를 마치 조립용 레고 블록처럼 다룰 수 있어 매우 유연하게 페이지를 구성한다.

쉽고 간단한 업데이트
------
　업데이트한 웹 페이지릐 정보를 교체하는 일이다. 웹에서 페이지를 업데이트하려면 문서 객체 모델(Document Object Model, DOM)을 조작해야 한다. 돔은 HTML 코드를 트리 형태로 변환한 구성물이다. 돔은 웹 브라우저가 직접 생성하며, HTML 코드를 렌더링하기위해 만든다. 렌더링(Rendering)이란 브라우저가 웹의 3가지 언어 HTML, CSS, 자바스크립트를 해석해 페이지의 요소를 실제로 그려내는 과정이다.

빠른 업데이트
------
　리액트는 빠른 업데이트를 제공한다.

리액트 앱 만들기
======
　리액트 웹이 아닌 앱으로 부르는 까닭은 리액트로 만든 웹 서비스는 마치 애플리케이션처럼 다양하게 상호작용할 수 있는 기능을 제공하기 때문이다.

Create React App으로 리액트 앱 만들기
------
　Create React App은 복잡한 설정 없이 리액트 앱을 만들어 주는 라이브러리이다. 다음 코드를 비주얼 스튜디어 코드의 터미널에 입력한다.
```
npx create-react-app .
```

리액트 앱의 구성요소 살펴보기
------
　package.json, package-lock.jsom, node_modules 같은 Node.js 패키지 구성파일이 존재한다.

리액트 앱 실행하기
------
　다음 명령을 입력해 start 스크립트를 실행한다.
```
npm run start
```

리액트 앱의 동작 원리
======
　리액트 앱이 어떻게 동작하는지 그 원리를 좀 더 자세히 살펴본다.

리액트 앱에는 어떻게 접속하는 걸까?
------
　Create React App으로 만든 리액트 앱에는 웹 서버가 내장되어 있다. 즉, npm run start 명령을 실행하면 브라우저가 리액트 앱에 접속하도록 앱에 내장된 웹 서버가 동작한다. 결국 내장된 앱 서버 주소로 브라우저가 자동으로 접속한다.

리액트 앱의 동작 원리 상세 보기
------
　리액트 앱의 동작 방식을 정리하면 다음과 같다.
* localhost:3000으로 접속을 요청하면 public 폴더의 index.html을 반환한다.
* index.html은 src 폴더의 index.js와 해당 파일이 가져오는 자바스크립트 파일을 한데 묶어 놓은 bundle.js를 불러온다.
* bundle.js가 실행되어 index.js에서 작성한 코드가 실행된다.
* index.js는 ReactDOM.createRoot 메서드로 돔에서 리액트 앱의 루트가 될 요소를 지정한다.
* render 매서드를 사용해 돔의 루트 아래에 자식 컴포넌트를 추가한다. 결과적으로 App 컴포넌트가 렌더링된다.